

Terminals which are not used:

   DEFINE
   UNDEF
   TYPEDEF_ID
   INCLUDE
   DO
   OPERATOR
   VIRTUAL
   LAST_PREC


Conflict in state 181 between rule 190 and token LE resolved as reduce.
Conflict in state 181 between rule 190 and token GE resolved as reduce.
Conflict in state 181 between rule 190 and token EQ resolved as reduce.
Conflict in state 181 between rule 190 and token NE resolved as reduce.
Conflict in state 181 between rule 190 and token '<' resolved as reduce.
Conflict in state 181 between rule 190 and token '>' resolved as reduce.
Conflict in state 181 between rule 190 and token '+' resolved as reduce.
Conflict in state 181 between rule 190 and token '-' resolved as reduce.
Conflict in state 181 between rule 190 and token ANDAND resolved as reduce.
Conflict in state 181 between rule 190 and token OROR resolved as reduce.
Conflict in state 181 between rule 190 and token '*' resolved as reduce.
Conflict in state 181 between rule 190 and token '/' resolved as reduce.
Conflict in state 181 between rule 190 and token ICR resolved as reduce.
Conflict in state 181 between rule 190 and token DECR resolved as reduce.
Conflict in state 182 between rule 184 and token LE resolved as reduce.
Conflict in state 182 between rule 184 and token GE resolved as reduce.
Conflict in state 182 between rule 184 and token EQ resolved as reduce.
Conflict in state 182 between rule 184 and token NE resolved as reduce.
Conflict in state 182 between rule 184 and token '<' resolved as reduce.
Conflict in state 182 between rule 184 and token '>' resolved as reduce.
Conflict in state 182 between rule 184 and token '+' resolved as reduce.
Conflict in state 182 between rule 184 and token '-' resolved as reduce.
Conflict in state 182 between rule 184 and token ANDAND resolved as reduce.
Conflict in state 182 between rule 184 and token OROR resolved as reduce.
Conflict in state 182 between rule 184 and token '*' resolved as reduce.
Conflict in state 182 between rule 184 and token '/' resolved as reduce.
Conflict in state 182 between rule 184 and token ICR resolved as reduce.
Conflict in state 182 between rule 184 and token DECR resolved as reduce.
Conflict in state 185 between rule 183 and token LE resolved as reduce.
Conflict in state 185 between rule 183 and token GE resolved as reduce.
Conflict in state 185 between rule 183 and token EQ resolved as reduce.
Conflict in state 185 between rule 183 and token NE resolved as reduce.
Conflict in state 185 between rule 183 and token '<' resolved as reduce.
Conflict in state 185 between rule 183 and token '>' resolved as reduce.
Conflict in state 185 between rule 183 and token '+' resolved as reduce.
Conflict in state 185 between rule 183 and token '-' resolved as reduce.
Conflict in state 185 between rule 183 and token ANDAND resolved as reduce.
Conflict in state 185 between rule 183 and token OROR resolved as reduce.
Conflict in state 185 between rule 183 and token '*' resolved as reduce.
Conflict in state 185 between rule 183 and token '/' resolved as reduce.
Conflict in state 185 between rule 183 and token ICR resolved as reduce.
Conflict in state 185 between rule 183 and token DECR resolved as reduce.
Conflict in state 188 between rule 185 and token LE resolved as reduce.
Conflict in state 188 between rule 185 and token GE resolved as reduce.
Conflict in state 188 between rule 185 and token EQ resolved as reduce.
Conflict in state 188 between rule 185 and token NE resolved as reduce.
Conflict in state 188 between rule 185 and token '<' resolved as reduce.
Conflict in state 188 between rule 185 and token '>' resolved as reduce.
Conflict in state 188 between rule 185 and token '+' resolved as reduce.
Conflict in state 188 between rule 185 and token '-' resolved as reduce.
Conflict in state 188 between rule 185 and token ANDAND resolved as reduce.
Conflict in state 188 between rule 185 and token OROR resolved as reduce.
Conflict in state 188 between rule 185 and token '*' resolved as reduce.
Conflict in state 188 between rule 185 and token '/' resolved as reduce.
Conflict in state 188 between rule 185 and token ICR resolved as reduce.
Conflict in state 188 between rule 185 and token DECR resolved as reduce.
Conflict in state 189 between rule 187 and token LE resolved as reduce.
Conflict in state 189 between rule 187 and token GE resolved as reduce.
Conflict in state 189 between rule 187 and token EQ resolved as reduce.
Conflict in state 189 between rule 187 and token NE resolved as reduce.
Conflict in state 189 between rule 187 and token '<' resolved as reduce.
Conflict in state 189 between rule 187 and token '>' resolved as reduce.
Conflict in state 189 between rule 187 and token '+' resolved as reduce.
Conflict in state 189 between rule 187 and token '-' resolved as reduce.
Conflict in state 189 between rule 187 and token ANDAND resolved as reduce.
Conflict in state 189 between rule 187 and token OROR resolved as reduce.
Conflict in state 189 between rule 187 and token '*' resolved as reduce.
Conflict in state 189 between rule 187 and token '/' resolved as reduce.
Conflict in state 189 between rule 187 and token ICR resolved as reduce.
Conflict in state 189 between rule 187 and token DECR resolved as reduce.
Conflict in state 239 between rule 197 and token LE resolved as reduce.
Conflict in state 239 between rule 197 and token GE resolved as reduce.
Conflict in state 239 between rule 197 and token EQ resolved as reduce.
Conflict in state 239 between rule 197 and token NE resolved as reduce.
Conflict in state 239 between rule 197 and token '<' resolved as reduce.
Conflict in state 239 between rule 197 and token '>' resolved as reduce.
Conflict in state 239 between rule 197 and token '+' resolved as shift.
Conflict in state 239 between rule 197 and token '-' resolved as shift.
Conflict in state 239 between rule 197 and token ANDAND resolved as shift.
Conflict in state 239 between rule 197 and token OROR resolved as shift.
Conflict in state 239 between rule 197 and token '*' resolved as shift.
Conflict in state 239 between rule 197 and token '/' resolved as shift.
Conflict in state 239 between rule 197 and token ICR resolved as shift.
Conflict in state 239 between rule 197 and token DECR resolved as shift.
Conflict in state 240 between rule 198 and token LE resolved as reduce.
Conflict in state 240 between rule 198 and token GE resolved as reduce.
Conflict in state 240 between rule 198 and token EQ resolved as reduce.
Conflict in state 240 between rule 198 and token NE resolved as reduce.
Conflict in state 240 between rule 198 and token '<' resolved as reduce.
Conflict in state 240 between rule 198 and token '>' resolved as reduce.
Conflict in state 240 between rule 198 and token '+' resolved as shift.
Conflict in state 240 between rule 198 and token '-' resolved as shift.
Conflict in state 240 between rule 198 and token ANDAND resolved as shift.
Conflict in state 240 between rule 198 and token OROR resolved as shift.
Conflict in state 240 between rule 198 and token '*' resolved as shift.
Conflict in state 240 between rule 198 and token '/' resolved as shift.
Conflict in state 240 between rule 198 and token ICR resolved as shift.
Conflict in state 240 between rule 198 and token DECR resolved as shift.
Conflict in state 241 between rule 199 and token LE resolved as reduce.
Conflict in state 241 between rule 199 and token GE resolved as reduce.
Conflict in state 241 between rule 199 and token EQ resolved as reduce.
Conflict in state 241 between rule 199 and token NE resolved as reduce.
Conflict in state 241 between rule 199 and token '<' resolved as reduce.
Conflict in state 241 between rule 199 and token '>' resolved as reduce.
Conflict in state 241 between rule 199 and token '+' resolved as shift.
Conflict in state 241 between rule 199 and token '-' resolved as shift.
Conflict in state 241 between rule 199 and token ANDAND resolved as shift.
Conflict in state 241 between rule 199 and token OROR resolved as shift.
Conflict in state 241 between rule 199 and token '*' resolved as shift.
Conflict in state 241 between rule 199 and token '/' resolved as shift.
Conflict in state 241 between rule 199 and token ICR resolved as shift.
Conflict in state 241 between rule 199 and token DECR resolved as shift.
Conflict in state 242 between rule 200 and token LE resolved as reduce.
Conflict in state 242 between rule 200 and token GE resolved as reduce.
Conflict in state 242 between rule 200 and token EQ resolved as reduce.
Conflict in state 242 between rule 200 and token NE resolved as reduce.
Conflict in state 242 between rule 200 and token '<' resolved as reduce.
Conflict in state 242 between rule 200 and token '>' resolved as reduce.
Conflict in state 242 between rule 200 and token '+' resolved as shift.
Conflict in state 242 between rule 200 and token '-' resolved as shift.
Conflict in state 242 between rule 200 and token ANDAND resolved as shift.
Conflict in state 242 between rule 200 and token OROR resolved as shift.
Conflict in state 242 between rule 200 and token '*' resolved as shift.
Conflict in state 242 between rule 200 and token '/' resolved as shift.
Conflict in state 242 between rule 200 and token ICR resolved as shift.
Conflict in state 242 between rule 200 and token DECR resolved as shift.
Conflict in state 243 between rule 195 and token LE resolved as reduce.
Conflict in state 243 between rule 195 and token GE resolved as reduce.
Conflict in state 243 between rule 195 and token EQ resolved as reduce.
Conflict in state 243 between rule 195 and token NE resolved as reduce.
Conflict in state 243 between rule 195 and token '<' resolved as reduce.
Conflict in state 243 between rule 195 and token '>' resolved as reduce.
Conflict in state 243 between rule 195 and token '+' resolved as shift.
Conflict in state 243 between rule 195 and token '-' resolved as shift.
Conflict in state 243 between rule 195 and token ANDAND resolved as shift.
Conflict in state 243 between rule 195 and token OROR resolved as shift.
Conflict in state 243 between rule 195 and token '*' resolved as shift.
Conflict in state 243 between rule 195 and token '/' resolved as shift.
Conflict in state 243 between rule 195 and token ICR resolved as shift.
Conflict in state 243 between rule 195 and token DECR resolved as shift.
Conflict in state 244 between rule 196 and token LE resolved as reduce.
Conflict in state 244 between rule 196 and token GE resolved as reduce.
Conflict in state 244 between rule 196 and token EQ resolved as reduce.
Conflict in state 244 between rule 196 and token NE resolved as reduce.
Conflict in state 244 between rule 196 and token '<' resolved as reduce.
Conflict in state 244 between rule 196 and token '>' resolved as reduce.
Conflict in state 244 between rule 196 and token '+' resolved as shift.
Conflict in state 244 between rule 196 and token '-' resolved as shift.
Conflict in state 244 between rule 196 and token ANDAND resolved as shift.
Conflict in state 244 between rule 196 and token OROR resolved as shift.
Conflict in state 244 between rule 196 and token '*' resolved as shift.
Conflict in state 244 between rule 196 and token '/' resolved as shift.
Conflict in state 244 between rule 196 and token ICR resolved as shift.
Conflict in state 244 between rule 196 and token DECR resolved as shift.
Conflict in state 245 between rule 191 and token LE resolved as reduce.
Conflict in state 245 between rule 191 and token GE resolved as reduce.
Conflict in state 245 between rule 191 and token EQ resolved as reduce.
Conflict in state 245 between rule 191 and token NE resolved as reduce.
Conflict in state 245 between rule 191 and token '<' resolved as reduce.
Conflict in state 245 between rule 191 and token '>' resolved as reduce.
Conflict in state 245 between rule 191 and token '+' resolved as reduce.
Conflict in state 245 between rule 191 and token '-' resolved as reduce.
Conflict in state 245 between rule 191 and token ANDAND resolved as reduce.
Conflict in state 245 between rule 191 and token OROR resolved as reduce.
Conflict in state 245 between rule 191 and token '*' resolved as shift.
Conflict in state 245 between rule 191 and token '/' resolved as shift.
Conflict in state 245 between rule 191 and token ICR resolved as shift.
Conflict in state 245 between rule 191 and token DECR resolved as shift.
Conflict in state 246 between rule 192 and token LE resolved as reduce.
Conflict in state 246 between rule 192 and token GE resolved as reduce.
Conflict in state 246 between rule 192 and token EQ resolved as reduce.
Conflict in state 246 between rule 192 and token NE resolved as reduce.
Conflict in state 246 between rule 192 and token '<' resolved as reduce.
Conflict in state 246 between rule 192 and token '>' resolved as reduce.
Conflict in state 246 between rule 192 and token '+' resolved as reduce.
Conflict in state 246 between rule 192 and token '-' resolved as reduce.
Conflict in state 246 between rule 192 and token ANDAND resolved as reduce.
Conflict in state 246 between rule 192 and token OROR resolved as reduce.
Conflict in state 246 between rule 192 and token '*' resolved as shift.
Conflict in state 246 between rule 192 and token '/' resolved as shift.
Conflict in state 246 between rule 192 and token ICR resolved as shift.
Conflict in state 246 between rule 192 and token DECR resolved as shift.
Conflict in state 247 between rule 202 and token LE resolved as reduce.
Conflict in state 247 between rule 202 and token GE resolved as reduce.
Conflict in state 247 between rule 202 and token EQ resolved as reduce.
Conflict in state 247 between rule 202 and token NE resolved as reduce.
Conflict in state 247 between rule 202 and token '<' resolved as reduce.
Conflict in state 247 between rule 202 and token '>' resolved as reduce.
Conflict in state 247 between rule 202 and token '+' resolved as reduce.
Conflict in state 247 between rule 202 and token '-' resolved as reduce.
Conflict in state 247 between rule 202 and token ANDAND resolved as reduce.
Conflict in state 247 between rule 202 and token OROR resolved as reduce.
Conflict in state 247 between rule 202 and token '*' resolved as shift.
Conflict in state 247 between rule 202 and token '/' resolved as shift.
Conflict in state 247 between rule 202 and token ICR resolved as shift.
Conflict in state 247 between rule 202 and token DECR resolved as shift.
Conflict in state 248 between rule 201 and token LE resolved as reduce.
Conflict in state 248 between rule 201 and token GE resolved as reduce.
Conflict in state 248 between rule 201 and token EQ resolved as reduce.
Conflict in state 248 between rule 201 and token NE resolved as reduce.
Conflict in state 248 between rule 201 and token '<' resolved as reduce.
Conflict in state 248 between rule 201 and token '>' resolved as reduce.
Conflict in state 248 between rule 201 and token '+' resolved as reduce.
Conflict in state 248 between rule 201 and token '-' resolved as reduce.
Conflict in state 248 between rule 201 and token ANDAND resolved as reduce.
Conflict in state 248 between rule 201 and token OROR resolved as reduce.
Conflict in state 248 between rule 201 and token '*' resolved as shift.
Conflict in state 248 between rule 201 and token '/' resolved as shift.
Conflict in state 248 between rule 201 and token ICR resolved as shift.
Conflict in state 248 between rule 201 and token DECR resolved as shift.
Conflict in state 249 between rule 194 and token LE resolved as reduce.
Conflict in state 249 between rule 194 and token GE resolved as reduce.
Conflict in state 249 between rule 194 and token EQ resolved as reduce.
Conflict in state 249 between rule 194 and token NE resolved as reduce.
Conflict in state 249 between rule 194 and token '<' resolved as reduce.
Conflict in state 249 between rule 194 and token '>' resolved as reduce.
Conflict in state 249 between rule 194 and token '+' resolved as reduce.
Conflict in state 249 between rule 194 and token '-' resolved as reduce.
Conflict in state 249 between rule 194 and token ANDAND resolved as reduce.
Conflict in state 249 between rule 194 and token OROR resolved as reduce.
Conflict in state 249 between rule 194 and token '*' resolved as reduce.
Conflict in state 249 between rule 194 and token '/' resolved as reduce.
Conflict in state 249 between rule 194 and token ICR resolved as shift.
Conflict in state 249 between rule 194 and token DECR resolved as shift.
Conflict in state 250 between rule 193 and token LE resolved as reduce.
Conflict in state 250 between rule 193 and token GE resolved as reduce.
Conflict in state 250 between rule 193 and token EQ resolved as reduce.
Conflict in state 250 between rule 193 and token NE resolved as reduce.
Conflict in state 250 between rule 193 and token '<' resolved as reduce.
Conflict in state 250 between rule 193 and token '>' resolved as reduce.
Conflict in state 250 between rule 193 and token '+' resolved as reduce.
Conflict in state 250 between rule 193 and token '-' resolved as reduce.
Conflict in state 250 between rule 193 and token ANDAND resolved as reduce.
Conflict in state 250 between rule 193 and token OROR resolved as reduce.
Conflict in state 250 between rule 193 and token '*' resolved as reduce.
Conflict in state 250 between rule 193 and token '/' resolved as reduce.
Conflict in state 250 between rule 193 and token ICR resolved as shift.
Conflict in state 250 between rule 193 and token DECR resolved as shift.
Conflict in state 381 between rule 137 and token ELSE resolved as shift.

Grammar
rule 1    program -> prog_decls
rule 2    prog_decls ->		/* empty */
rule 3    prog_decls -> prog_decls declaration
rule 4    prog_decls -> prog_decls error
rule 5    declaration -> var_decl ';'
rule 6    declaration -> func_decl
rule 7    declaration -> func_def
rule 8    declaration -> class_decl
rule 9    declaration -> class_func_def
rule 10   declaration -> class_def
rule 11   declaration -> class_static_init_var ';'
rule 12   declaration -> class_destructor
rule 13   declaration -> class_constructor
rule 14   class_def -> class_head class_body
rule 15   class_def -> class_head ':' access_spec class_base_list class_body
rule 16   class_head -> CLASS class_type
rule 17   access_spec -> PUBLIC
rule 18   access_spec -> PROTECTED
rule 19   access_spec -> PRIVATE
rule 20   access_spec -> FRIEND
rule 21   class_base_list -> class_type
rule 22   class_base_list -> class_base_list ',' class_type
rule 23   class_body -> '{' '}' ';'
rule 24   class_body -> '{' class_body_stmts '}' ';'
rule 25   class_body_stmts -> class_body_stmt
rule 26   class_body_stmts -> class_body_stmts class_body_stmt
rule 27   class_body_stmt -> access_spec ':'
rule 28   class_body_stmt -> func_decl
rule 29   class_body_stmt -> func_def
rule 30   class_body_stmt -> var_decl ';'
rule 31   class_body_stmt -> class_constructor_decl
rule 32   class_body_stmt -> class_destructor_decl
rule 33   class_body_stmt -> error ';'
rule 34   class_body_stmt -> error '}'
rule 35   class_constructor_decl -> class_type '(' func_decl_args ')' ';'
rule 36   class_constructor -> class_type SCOPE_DOTS class_type '(' func_decl_args ')' class_constructor_init_list block_stmt
rule 37   class_constructor_init_list ->		/* empty */
rule 38   class_constructor_init_list -> ':' c_c_init_list
rule 39   c_c_init_list -> ID_NAME '(' const_expr ')'
rule 40   c_c_init_list -> c_c_init_list ',' ID_NAME '(' expr ')'
rule 41   class_destructor_decl -> '~' class_type '(' ')' ';'
rule 42   class_decl -> class_head ';'
rule 43   func_decl -> storage_spec type ID_NAME '(' func_decl_args ')' ';'
rule 44   func_decl -> type ID_NAME '(' func_decl_args ')' ';'
rule 45   func_decl -> storage_spec type ID_NAME '(' func_decl_args ')' CONST ';'
rule 46   func_decl -> type ID_NAME '(' func_decl_args ')' CONST ';'
rule 47   storage_spec -> STATIC
rule 48   storage_spec -> CONST
rule 49   storage_spec -> EXTERN
rule 50   storage_spec -> STATIC CONST
rule 51   storage_spec -> CONST STATIC
rule 52   func_decl_args ->		/* empty */
rule 53   func_decl_args -> func_decl_arg_list
rule 54   func_decl_arg_list -> func_decl_arg_elem
rule 55   func_decl_arg_list -> func_decl_arg_list ',' func_decl_arg_elem
rule 56   func_decl_arg_elem -> type
rule 57   func_decl_arg_elem -> type ID_NAME
rule 58   func_decl_arg_elem -> type ID_NAME '=' const_expr
rule 59   func_def -> func_def_inline
rule 60   func_def -> func_def_normal
rule 61   func_def_inline -> storage_spec INLINE func_def_common
rule 62   func_def_inline -> INLINE func_def_common
rule 63   func_def_normal -> storage_spec func_def_common
rule 64   func_def_normal -> func_def_common
rule 65   func_def_common -> type ID_NAME '(' func_decl_args ')' block_stmt
rule 66   func_def_common -> type ID_NAME '(' func_decl_args ')' CONST block_stmt
rule 67   class_func_def -> class_func_def_inline
rule 68   class_func_def -> class_func_def_normal
rule 69   class_func_def_inline -> storage_spec INLINE class_func_def_common
rule 70   class_func_def_inline -> INLINE class_func_def_common
rule 71   class_func_def_normal -> storage_spec class_func_def_common
rule 72   class_func_def_normal -> class_func_def_common
rule 73   class_func_def_common -> type class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt
rule 74   stmts -> stmt
rule 75   stmts -> stmts stmt
rule 76   stmt -> simple_stmt ';'
rule 77   stmt -> compound_stmt
rule 78   stmt -> error ';'
rule 79   stmt -> error '}'
rule 80   simple_stmt -> var_decl
rule 81   simple_stmt -> assignment
rule 82   simple_stmt -> expr
rule 83   simple_stmt -> jump_stmt
rule 84   simple_stmt -> cin_stmt
rule 85   simple_stmt -> cout_stmt
rule 86   var_decl -> storage_spec type var_list
rule 87   var_decl -> type var_list
rule 88   var_list_elem -> ID_NAME
rule 89   var_list_elem -> ID_NAME array_dims
rule 90   var_list_elem -> ID_NAME '=' expr
rule 91   var_list_elem -> ID_NAME array_dims '=' array_init_list
rule 92   var_list -> var_list_elem
rule 93   var_list -> var_list ',' var_list_elem
rule 94   var_list -> ID_NAME '(' proc_expr_list_not_empty ')'
rule 95   array_dims -> array_dim
rule 96   array_dims -> array_dims array_dim
rule 97   array_dim -> '[' ']'
rule 98   array_dim -> '[' INTEGER_CONST ']'
rule 99   array_init_list -> '{' array_init_list_consts '}'
rule 100  array_init_list -> '{' array_init_list_lists '}'
rule 101  array_init_list_consts -> const_expr
rule 102  array_init_list_consts -> array_init_list_consts ',' const_expr
rule 103  array_init_list_lists -> array_init_list
rule 104  array_init_list_lists -> array_init_list_lists ',' array_init_list
rule 105  class_static_init_var -> type class_type SCOPE_DOTS ID_NAME '=' expr
rule 106  class_destructor -> class_type SCOPE_DOTS '~' class_type '(' ')' block_stmt
rule 107  assignment -> var_expr '=' expr
rule 108  assignment -> var_expr PLUS_EQ expr
rule 109  assignment -> var_expr MINUS_EQ expr
rule 110  assignment -> var_expr DIV_EQ expr
rule 111  assignment -> var_expr MULT_EQ expr
rule 112  proc_call -> ID_NAME '(' proc_expr_list ')'
rule 113  proc_call -> ID_NAME '.' ID_NAME '(' proc_expr_list ')'
rule 114  proc_call -> THIS ARROW proc_call
rule 115  proc_call -> class_type SCOPE_DOTS ID_NAME '(' proc_expr_list ')'
rule 116  proc_expr_list ->		/* empty */
rule 117  proc_expr_list -> proc_expr_list_not_empty
rule 118  proc_expr_list_not_empty -> expr
rule 119  proc_expr_list_not_empty -> proc_expr_list_not_empty ',' expr
rule 120  jump_stmt -> BREAK
rule 121  jump_stmt -> RETURN expr
rule 122  jump_stmt -> CONTINUE
rule 123  cin_stmt -> CIN cin_stmt_input_list
rule 124  cin_stmt_input_list -> input_elem
rule 125  cin_stmt_input_list -> cin_stmt_input_list input_elem
rule 126  input_elem -> INPUT_VAR_SYM var_expr
rule 127  cout_stmt -> COUT cout_stmt_output_list
rule 128  cout_stmt_output_list -> output_elem
rule 129  cout_stmt_output_list -> cout_stmt_output_list output_elem
rule 130  output_elem -> OUTPUT_VAR_SYM expr
rule 131  compound_stmt -> if_stmt
rule 132  compound_stmt -> for_stmt
rule 133  compound_stmt -> while_stmt
rule 134  compound_stmt -> block_stmt
rule 135  block_stmt -> '{' '}'
rule 136  block_stmt -> '{' stmts '}'
rule 137  if_stmt -> IF '(' expr ')' stmt
rule 138  if_stmt -> IF '(' expr ')' stmt ELSE stmt
rule 139  for_stmt -> FOR '(' var_decl ';' expr ';' for_itr ')' block_stmt
rule 140  for_itr -> for_itr_elem
rule 141  for_itr -> for_itr ',' for_itr_elem
rule 142  for_itr_elem -> expr
rule 143  for_itr_elem -> assignment
rule 144  while_stmt -> WHILE '(' expr ')' stmt
rule 145  type -> simple_type
rule 146  type -> complex_type
rule 147  simple_type -> INT
rule 148  simple_type -> DOUBLE
rule 149  simple_type -> BOOL_TYPE
rule 150  simple_type -> CHAR
rule 151  simple_type -> VOID
rule 152  complex_type -> pointer_type
rule 153  complex_type -> reference_type
rule 154  complex_type -> class_type
rule 155  pointer_type -> type '*'
rule 156  reference_type -> type '&'
rule 157  expr -> const_expr
rule 158  expr -> var_expr
rule 159  expr -> unary_expr
rule 160  expr -> binary_expr
rule 161  expr -> allocate_expr
rule 162  expr -> proc_call
rule 163  expr -> cast_expr
rule 164  expr -> '(' expr ')'
rule 165  const_expr -> INTEGER_CONST
rule 166  const_expr -> DOUBLE_CONST
rule 167  const_expr -> CHARACTER_CONST
rule 168  const_expr -> STRING_CONST
rule 169  const_expr -> FALSE_CONST
rule 170  const_expr -> TRUE_CONST
rule 171  var_expr -> array_expr
rule 172  var_expr -> pointer_val_expr
rule 173  var_expr -> ID_NAME
rule 174  var_expr -> THIS
rule 175  var_expr -> ID_NAME '.' var_expr
rule 176  var_expr -> class_type SCOPE_DOTS ID_NAME
rule 177  var_expr -> ID_NAME ARROW ID_NAME
rule 178  var_expr -> THIS ARROW var_expr
rule 179  array_expr -> ID_NAME array_expr_dims
rule 180  array_expr_dims -> '[' expr ']'
rule 181  array_expr_dims -> array_expr_dims '[' expr ']'
rule 182  pointer_val_expr -> '*' var_expr
rule 183  unary_expr -> '!' expr
rule 184  unary_expr -> '-' expr
rule 185  unary_expr -> ICR expr
rule 186  unary_expr -> expr ICR
rule 187  unary_expr -> DECR expr
rule 188  unary_expr -> expr DECR
rule 189  unary_expr -> '&' var_expr
rule 190  unary_expr -> '+' expr
rule 191  binary_expr -> expr '+' expr
rule 192  binary_expr -> expr '-' expr
rule 193  binary_expr -> expr '/' expr
rule 194  binary_expr -> expr '*' expr
rule 195  binary_expr -> expr '<' expr
rule 196  binary_expr -> expr '>' expr
rule 197  binary_expr -> expr LE expr
rule 198  binary_expr -> expr GE expr
rule 199  binary_expr -> expr EQ expr
rule 200  binary_expr -> expr NE expr
rule 201  binary_expr -> expr OROR expr
rule 202  binary_expr -> expr ANDAND expr
rule 203  allocate_expr -> new_expr
rule 204  allocate_expr -> delete_expr
rule 205  new_expr -> NEW type '[' expr ']'
rule 206  new_expr -> NEW type '(' expr_list ')'
rule 207  expr_list ->		/* empty */
rule 208  expr_list -> expr
rule 209  expr_list -> expr_list ',' expr
rule 210  delete_expr -> DELETE var_expr
rule 211  delete_expr -> DELETE '[' ']' var_expr
rule 212  cast_expr -> '(' type ')' var_expr
rule 213  class_type -> CLASS_ID

Terminals, with rules where they appear

$ (-1)
'!' (33) 183
'&' (38) 156 189
'(' (40) 35 36 39 40 41 43 44 45 46 65 66 73 94 106 112 113 115 137
    138 139 144 164 206 212
')' (41) 35 36 39 40 41 43 44 45 46 65 66 73 94 106 112 113 115 137
    138 139 144 164 206 212
'*' (42) 155 182 194
'+' (43) 190 191
',' (44) 22 40 55 93 102 104 119 141 209
'-' (45) 184 192
'.' (46) 113 175
'/' (47) 193
':' (58) 15 27 38
';' (59) 5 11 23 24 30 33 35 41 42 43 44 45 46 76 78 139
'<' (60) 195
'=' (61) 58 90 91 105 107
'>' (62) 196
'[' (91) 97 98 180 181 205 211
']' (93) 97 98 180 181 205 211
'{' (123) 23 24 99 100 135 136
'}' (125) 23 24 34 79 99 100 135 136
'~' (126) 41 106
error (256) 4 33 34 78 79
EXTERN (258) 49
CIN (259) 123
DEFINE (260)
BREAK (261) 120
COUT (262) 127
UNDEF (263)
FOR (264) 139
TYPEDEF_ID (265)
DOUBLE (266) 148
INCLUDE (267)
RETURN (268) 121
DO (269)
WHILE (270) 144
CONTINUE (271) 122
ID_NAME (272) 39 40 43 44 45 46 57 58 65 66 73 88 89 90 91 94 105 112
    113 115 173 175 176 177 179
CLASS_ID (273) 213
INT (274) 147
BOOL_TYPE (275) 149
CHAR (276) 150
STATIC (277) 47 50 51
CONST (278) 45 46 48 50 51 66
INTEGER_CONST (279) 98 165
DOUBLE_CONST (280) 166
STRING_CONST (281) 168
CHARACTER_CONST (282) 167
FALSE_CONST (283) 169
TRUE_CONST (284) 170
VOID (285) 151
PUBLIC (286) 17
PROTECTED (287) 18
PRIVATE (288) 19
FRIEND (289) 20
NEW (290) 205 206
DELETE (291) 210 211
THIS (292) 114 174 178
OPERATOR (293)
CLASS (294) 16
INLINE (295) 61 62 69 70
VIRTUAL (296)
INPUT_VAR_SYM (297) 126
OUTPUT_VAR_SYM (298) 130
PLUS_EQ (299) 108
MULT_EQ (300) 111
MINUS_EQ (301) 109
DIV_EQ (302) 110
LE (303) 197
GE (304) 198
EQ (305) 199
NE (306) 200
ANDAND (307) 202
OROR (308) 201
ICR (309) 185 186
DECR (310) 187 188
POS_NEG (311)
LAST_PREC (312)
ARROW (313) 114 177 178
SCOPE_DOTS (314) 36 73 105 106 115 176
IF (315) 137 138
ELSE (316) 138

Nonterminals, with rules where they appear

program (82)
    on left: 1
prog_decls (83)
    on left: 2 3 4, on right: 1 3 4
declaration (84)
    on left: 5 6 7 8 9 10 11 12 13, on right: 3
class_def (85)
    on left: 14 15, on right: 10
class_head (86)
    on left: 16, on right: 14 15 42
access_spec (87)
    on left: 17 18 19 20, on right: 15 27
class_base_list (88)
    on left: 21 22, on right: 15 22
class_body (89)
    on left: 23 24, on right: 14 15
class_body_stmts (90)
    on left: 25 26, on right: 24 26
class_body_stmt (91)
    on left: 27 28 29 30 31 32 33 34, on right: 25 26
class_constructor_decl (92)
    on left: 35, on right: 31
class_constructor (93)
    on left: 36, on right: 13
class_constructor_init_list (94)
    on left: 37 38, on right: 36
c_c_init_list (95)
    on left: 39 40, on right: 38 40
class_destructor_decl (96)
    on left: 41, on right: 32
class_decl (97)
    on left: 42, on right: 8
func_decl (98)
    on left: 43 44 45 46, on right: 6 28
storage_spec (99)
    on left: 47 48 49 50 51, on right: 43 45 61 63 69 71 86
func_decl_args (100)
    on left: 52 53, on right: 35 36 43 44 45 46 65 66 73
func_decl_arg_list (101)
    on left: 54 55, on right: 53 55
func_decl_arg_elem (102)
    on left: 56 57 58, on right: 54 55
func_def (103)
    on left: 59 60, on right: 7 29
func_def_inline (104)
    on left: 61 62, on right: 59
func_def_normal (105)
    on left: 63 64, on right: 60
func_def_common (106)
    on left: 65 66, on right: 61 62 63 64
class_func_def (107)
    on left: 67 68, on right: 9
class_func_def_inline (108)
    on left: 69 70, on right: 67
class_func_def_normal (109)
    on left: 71 72, on right: 68
class_func_def_common (110)
    on left: 73, on right: 69 70 71 72
stmts (111)
    on left: 74 75, on right: 75 136
stmt (112)
    on left: 76 77 78 79, on right: 74 75 137 138 144
simple_stmt (113)
    on left: 80 81 82 83 84 85, on right: 76
var_decl (114)
    on left: 86 87, on right: 5 30 80 139
var_list_elem (115)
    on left: 88 89 90 91, on right: 92 93
var_list (116)
    on left: 92 93 94, on right: 86 87 93
array_dims (117)
    on left: 95 96, on right: 89 91 96
array_dim (118)
    on left: 97 98, on right: 95 96
array_init_list (119)
    on left: 99 100, on right: 91 103 104
array_init_list_consts (120)
    on left: 101 102, on right: 99 102
array_init_list_lists (121)
    on left: 103 104, on right: 100 104
class_static_init_var (122)
    on left: 105, on right: 11
class_destructor (123)
    on left: 106, on right: 12
assignment (124)
    on left: 107 108 109 110 111, on right: 81 143
proc_call (125)
    on left: 112 113 114 115, on right: 114 162
proc_expr_list (126)
    on left: 116 117, on right: 112 113 115
proc_expr_list_not_empty (127)
    on left: 118 119, on right: 94 117 119
jump_stmt (128)
    on left: 120 121 122, on right: 83
cin_stmt (129)
    on left: 123, on right: 84
cin_stmt_input_list (130)
    on left: 124 125, on right: 123 125
input_elem (131)
    on left: 126, on right: 124 125
cout_stmt (132)
    on left: 127, on right: 85
cout_stmt_output_list (133)
    on left: 128 129, on right: 127 129
output_elem (134)
    on left: 130, on right: 128 129
compound_stmt (135)
    on left: 131 132 133 134, on right: 77
block_stmt (136)
    on left: 135 136, on right: 36 65 66 73 106 134 139
if_stmt (137)
    on left: 137 138, on right: 131
for_stmt (138)
    on left: 139, on right: 132
for_itr (139)
    on left: 140 141, on right: 139 141
for_itr_elem (140)
    on left: 142 143, on right: 140 141
while_stmt (141)
    on left: 144, on right: 133
type (142)
    on left: 145 146, on right: 43 44 45 46 56 57 58 65 66 73 86 87
    105 155 156 205 206 212
simple_type (143)
    on left: 147 148 149 150 151, on right: 145
complex_type (144)
    on left: 152 153 154, on right: 146
pointer_type (145)
    on left: 155, on right: 152
reference_type (146)
    on left: 156, on right: 153
expr (147)
    on left: 157 158 159 160 161 162 163 164, on right: 40 82 90 105
    107 108 109 110 111 118 119 121 130 137 138 139 142 144 164 180
    181 183 184 185 186 187 188 190 191 192 193 194 195 196 197 198
    199 200 201 202 205 208 209
const_expr (148)
    on left: 165 166 167 168 169 170, on right: 39 58 101 102 157
var_expr (149)
    on left: 171 172 173 174 175 176 177 178, on right: 107 108 109
    110 111 126 158 175 178 182 189 210 211 212
array_expr (150)
    on left: 179, on right: 171
array_expr_dims (151)
    on left: 180 181, on right: 179 181
pointer_val_expr (152)
    on left: 182, on right: 172
unary_expr (153)
    on left: 183 184 185 186 187 188 189 190, on right: 159
binary_expr (154)
    on left: 191 192 193 194 195 196 197 198 199 200 201 202,
    on right: 160
allocate_expr (155)
    on left: 203 204, on right: 161
new_expr (156)
    on left: 205 206, on right: 203
expr_list (157)
    on left: 207 208 209, on right: 206 209
delete_expr (158)
    on left: 210 211, on right: 204
cast_expr (159)
    on left: 212, on right: 163
class_type (160)
    on left: 213, on right: 16 21 22 35 36 41 73 105 106 115 154 176


state 0

    $default	reduce using rule 2 (prog_decls)

    program	go to state 397
    prog_decls	go to state 1



state 1

    program  ->  prog_decls .   (rule 1)
    prog_decls  ->  prog_decls . declaration   (rule 3)
    prog_decls  ->  prog_decls . error   (rule 4)

    error	shift, and go to state 2
    EXTERN	shift, and go to state 3
    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    VOID	shift, and go to state 11
    CLASS	shift, and go to state 12
    INLINE	shift, and go to state 13

    $   	reduce using rule 1 (program)

    declaration	go to state 14
    class_def	go to state 15
    class_head	go to state 16
    class_constructor	go to state 17
    class_decl	go to state 18
    func_decl	go to state 19
    storage_spec	go to state 20
    func_def	go to state 21
    func_def_inline	go to state 22
    func_def_normal	go to state 23
    func_def_common	go to state 24
    class_func_def	go to state 25
    class_func_def_inline	go to state 26
    class_func_def_normal	go to state 27
    class_func_def_common	go to state 28
    var_decl	go to state 29
    class_static_init_var	go to state 30
    class_destructor	go to state 31
    type	go to state 32
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 37



state 2

    prog_decls  ->  prog_decls error .   (rule 4)

    $default	reduce using rule 4 (prog_decls)



state 3

    storage_spec  ->  EXTERN .   (rule 49)

    $default	reduce using rule 49 (storage_spec)



state 4

    simple_type  ->  DOUBLE .   (rule 148)

    $default	reduce using rule 148 (simple_type)



state 5

    class_type  ->  CLASS_ID .   (rule 213)

    $default	reduce using rule 213 (class_type)



state 6

    simple_type  ->  INT .   (rule 147)

    $default	reduce using rule 147 (simple_type)



state 7

    simple_type  ->  BOOL_TYPE .   (rule 149)

    $default	reduce using rule 149 (simple_type)



state 8

    simple_type  ->  CHAR .   (rule 150)

    $default	reduce using rule 150 (simple_type)



state 9

    storage_spec  ->  STATIC .   (rule 47)
    storage_spec  ->  STATIC . CONST   (rule 50)

    CONST	shift, and go to state 38

    $default	reduce using rule 47 (storage_spec)



state 10

    storage_spec  ->  CONST .   (rule 48)
    storage_spec  ->  CONST . STATIC   (rule 51)

    STATIC	shift, and go to state 39

    $default	reduce using rule 48 (storage_spec)



state 11

    simple_type  ->  VOID .   (rule 151)

    $default	reduce using rule 151 (simple_type)



state 12

    class_head  ->  CLASS . class_type   (rule 16)

    CLASS_ID	shift, and go to state 5

    class_type	go to state 40



state 13

    func_def_inline  ->  INLINE . func_def_common   (rule 62)
    class_func_def_inline  ->  INLINE . class_func_def_common   (rule 70)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    func_def_common	go to state 41
    class_func_def_common	go to state 42
    type	go to state 43
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 14

    prog_decls  ->  prog_decls declaration .   (rule 3)

    $default	reduce using rule 3 (prog_decls)



state 15

    declaration  ->  class_def .   (rule 10)

    $default	reduce using rule 10 (declaration)



state 16

    class_def  ->  class_head . class_body   (rule 14)
    class_def  ->  class_head . ':' access_spec class_base_list class_body   (rule 15)
    class_decl  ->  class_head . ';'   (rule 42)

    ';' 	shift, and go to state 45
    ':' 	shift, and go to state 46
    '{' 	shift, and go to state 47

    class_body	go to state 48



state 17

    declaration  ->  class_constructor .   (rule 13)

    $default	reduce using rule 13 (declaration)



state 18

    declaration  ->  class_decl .   (rule 8)

    $default	reduce using rule 8 (declaration)



state 19

    declaration  ->  func_decl .   (rule 6)

    $default	reduce using rule 6 (declaration)



state 20

    func_decl  ->  storage_spec . type ID_NAME '(' func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec . type ID_NAME '(' func_decl_args ')' CONST ';'   (rule 45)
    func_def_inline  ->  storage_spec . INLINE func_def_common   (rule 61)
    func_def_normal  ->  storage_spec . func_def_common   (rule 63)
    class_func_def_inline  ->  storage_spec . INLINE class_func_def_common   (rule 69)
    class_func_def_normal  ->  storage_spec . class_func_def_common   (rule 71)
    var_decl  ->  storage_spec . type var_list   (rule 86)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11
    INLINE	shift, and go to state 49

    func_def_common	go to state 50
    class_func_def_common	go to state 51
    type	go to state 52
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 21

    declaration  ->  func_def .   (rule 7)

    $default	reduce using rule 7 (declaration)



state 22

    func_def  ->  func_def_inline .   (rule 59)

    $default	reduce using rule 59 (func_def)



state 23

    func_def  ->  func_def_normal .   (rule 60)

    $default	reduce using rule 60 (func_def)



state 24

    func_def_normal  ->  func_def_common .   (rule 64)

    $default	reduce using rule 64 (func_def_normal)



state 25

    declaration  ->  class_func_def .   (rule 9)

    $default	reduce using rule 9 (declaration)



state 26

    class_func_def  ->  class_func_def_inline .   (rule 67)

    $default	reduce using rule 67 (class_func_def)



state 27

    class_func_def  ->  class_func_def_normal .   (rule 68)

    $default	reduce using rule 68 (class_func_def)



state 28

    class_func_def_normal  ->  class_func_def_common .   (rule 72)

    $default	reduce using rule 72 (class_func_def_normal)



state 29

    declaration  ->  var_decl . ';'   (rule 5)

    ';' 	shift, and go to state 53



state 30

    declaration  ->  class_static_init_var . ';'   (rule 11)

    ';' 	shift, and go to state 54



state 31

    declaration  ->  class_destructor .   (rule 12)

    $default	reduce using rule 12 (declaration)



state 32

    func_decl  ->  type . ID_NAME '(' func_decl_args ')' ';'   (rule 44)
    func_decl  ->  type . ID_NAME '(' func_decl_args ')' CONST ';'   (rule 46)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    class_func_def_common  ->  type . class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)
    var_decl  ->  type . var_list   (rule 87)
    class_static_init_var  ->  type . class_type SCOPE_DOTS ID_NAME '=' expr   (rule 105)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 55
    CLASS_ID	shift, and go to state 5
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 59
    class_type	go to state 60



state 33

    type  ->  simple_type .   (rule 145)

    $default	reduce using rule 145 (type)



state 34

    type  ->  complex_type .   (rule 146)

    $default	reduce using rule 146 (type)



state 35

    complex_type  ->  pointer_type .   (rule 152)

    $default	reduce using rule 152 (complex_type)



state 36

    complex_type  ->  reference_type .   (rule 153)

    $default	reduce using rule 153 (complex_type)



state 37

    class_constructor  ->  class_type . SCOPE_DOTS class_type '(' func_decl_args ')' class_constructor_init_list block_stmt   (rule 36)
    class_destructor  ->  class_type . SCOPE_DOTS '~' class_type '(' ')' block_stmt   (rule 106)
    complex_type  ->  class_type .   (rule 154)

    SCOPE_DOTS	shift, and go to state 61

    $default	reduce using rule 154 (complex_type)



state 38

    storage_spec  ->  STATIC CONST .   (rule 50)

    $default	reduce using rule 50 (storage_spec)



state 39

    storage_spec  ->  CONST STATIC .   (rule 51)

    $default	reduce using rule 51 (storage_spec)



state 40

    class_head  ->  CLASS class_type .   (rule 16)

    $default	reduce using rule 16 (class_head)



state 41

    func_def_inline  ->  INLINE func_def_common .   (rule 62)

    $default	reduce using rule 62 (func_def_inline)



state 42

    class_func_def_inline  ->  INLINE class_func_def_common .   (rule 70)

    $default	reduce using rule 70 (class_func_def_inline)



state 43

    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    class_func_def_common  ->  type . class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 62
    CLASS_ID	shift, and go to state 5
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    class_type	go to state 63



state 44

    complex_type  ->  class_type .   (rule 154)

    $default	reduce using rule 154 (complex_type)



state 45

    class_decl  ->  class_head ';' .   (rule 42)

    $default	reduce using rule 42 (class_decl)



state 46

    class_def  ->  class_head ':' . access_spec class_base_list class_body   (rule 15)

    PUBLIC	shift, and go to state 64
    PROTECTED	shift, and go to state 65
    PRIVATE	shift, and go to state 66
    FRIEND	shift, and go to state 67

    access_spec	go to state 68



state 47

    class_body  ->  '{' . '}' ';'   (rule 23)
    class_body  ->  '{' . class_body_stmts '}' ';'   (rule 24)

    error	shift, and go to state 69
    EXTERN	shift, and go to state 3
    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    VOID	shift, and go to state 11
    PUBLIC	shift, and go to state 64
    PROTECTED	shift, and go to state 65
    PRIVATE	shift, and go to state 66
    FRIEND	shift, and go to state 67
    INLINE	shift, and go to state 70
    '}' 	shift, and go to state 71
    '~' 	shift, and go to state 72

    access_spec	go to state 73
    class_body_stmts	go to state 74
    class_body_stmt	go to state 75
    class_constructor_decl	go to state 76
    class_destructor_decl	go to state 77
    func_decl	go to state 78
    storage_spec	go to state 79
    func_def	go to state 80
    func_def_inline	go to state 22
    func_def_normal	go to state 23
    func_def_common	go to state 24
    var_decl	go to state 81
    type	go to state 82
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 83



state 48

    class_def  ->  class_head class_body .   (rule 14)

    $default	reduce using rule 14 (class_def)



state 49

    func_def_inline  ->  storage_spec INLINE . func_def_common   (rule 61)
    class_func_def_inline  ->  storage_spec INLINE . class_func_def_common   (rule 69)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    func_def_common	go to state 84
    class_func_def_common	go to state 85
    type	go to state 43
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 50

    func_def_normal  ->  storage_spec func_def_common .   (rule 63)

    $default	reduce using rule 63 (func_def_normal)



state 51

    class_func_def_normal  ->  storage_spec class_func_def_common .   (rule 71)

    $default	reduce using rule 71 (class_func_def_normal)



state 52

    func_decl  ->  storage_spec type . ID_NAME '(' func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec type . ID_NAME '(' func_decl_args ')' CONST ';'   (rule 45)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    class_func_def_common  ->  type . class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)
    var_decl  ->  storage_spec type . var_list   (rule 86)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 86
    CLASS_ID	shift, and go to state 5
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 87
    class_type	go to state 63



state 53

    declaration  ->  var_decl ';' .   (rule 5)

    $default	reduce using rule 5 (declaration)



state 54

    declaration  ->  class_static_init_var ';' .   (rule 11)

    $default	reduce using rule 11 (declaration)



state 55

    func_decl  ->  type ID_NAME . '(' func_decl_args ')' ';'   (rule 44)
    func_decl  ->  type ID_NAME . '(' func_decl_args ')' CONST ';'   (rule 46)
    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' CONST block_stmt   (rule 66)
    var_list_elem  ->  ID_NAME .   (rule 88)
    var_list_elem  ->  ID_NAME . array_dims   (rule 89)
    var_list_elem  ->  ID_NAME . '=' expr   (rule 90)
    var_list_elem  ->  ID_NAME . array_dims '=' array_init_list   (rule 91)
    var_list  ->  ID_NAME . '(' proc_expr_list_not_empty ')'   (rule 94)

    '=' 	shift, and go to state 88
    '(' 	shift, and go to state 89
    '[' 	shift, and go to state 90

    $default	reduce using rule 88 (var_list_elem)

    array_dims	go to state 91
    array_dim	go to state 92



state 56

    pointer_type  ->  type '*' .   (rule 155)

    $default	reduce using rule 155 (pointer_type)



state 57

    reference_type  ->  type '&' .   (rule 156)

    $default	reduce using rule 156 (reference_type)



state 58

    var_list  ->  var_list_elem .   (rule 92)

    $default	reduce using rule 92 (var_list)



state 59

    var_decl  ->  type var_list .   (rule 87)
    var_list  ->  var_list . ',' var_list_elem   (rule 93)

    ',' 	shift, and go to state 93

    $default	reduce using rule 87 (var_decl)



state 60

    class_func_def_common  ->  type class_type . SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)
    class_static_init_var  ->  type class_type . SCOPE_DOTS ID_NAME '=' expr   (rule 105)

    SCOPE_DOTS	shift, and go to state 94



state 61

    class_constructor  ->  class_type SCOPE_DOTS . class_type '(' func_decl_args ')' class_constructor_init_list block_stmt   (rule 36)
    class_destructor  ->  class_type SCOPE_DOTS . '~' class_type '(' ')' block_stmt   (rule 106)

    CLASS_ID	shift, and go to state 5
    '~' 	shift, and go to state 95

    class_type	go to state 96



state 62

    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' CONST block_stmt   (rule 66)

    '(' 	shift, and go to state 97



state 63

    class_func_def_common  ->  type class_type . SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)

    SCOPE_DOTS	shift, and go to state 98



state 64

    access_spec  ->  PUBLIC .   (rule 17)

    $default	reduce using rule 17 (access_spec)



state 65

    access_spec  ->  PROTECTED .   (rule 18)

    $default	reduce using rule 18 (access_spec)



state 66

    access_spec  ->  PRIVATE .   (rule 19)

    $default	reduce using rule 19 (access_spec)



state 67

    access_spec  ->  FRIEND .   (rule 20)

    $default	reduce using rule 20 (access_spec)



state 68

    class_def  ->  class_head ':' access_spec . class_base_list class_body   (rule 15)

    CLASS_ID	shift, and go to state 5

    class_base_list	go to state 99
    class_type	go to state 100



state 69

    class_body_stmt  ->  error . ';'   (rule 33)
    class_body_stmt  ->  error . '}'   (rule 34)

    ';' 	shift, and go to state 101
    '}' 	shift, and go to state 102



state 70

    func_def_inline  ->  INLINE . func_def_common   (rule 62)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    func_def_common	go to state 41
    type	go to state 103
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 71

    class_body  ->  '{' '}' . ';'   (rule 23)

    ';' 	shift, and go to state 104



state 72

    class_destructor_decl  ->  '~' . class_type '(' ')' ';'   (rule 41)

    CLASS_ID	shift, and go to state 5

    class_type	go to state 105



state 73

    class_body_stmt  ->  access_spec . ':'   (rule 27)

    ':' 	shift, and go to state 106



state 74

    class_body  ->  '{' class_body_stmts . '}' ';'   (rule 24)
    class_body_stmts  ->  class_body_stmts . class_body_stmt   (rule 26)

    error	shift, and go to state 69
    EXTERN	shift, and go to state 3
    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    VOID	shift, and go to state 11
    PUBLIC	shift, and go to state 64
    PROTECTED	shift, and go to state 65
    PRIVATE	shift, and go to state 66
    FRIEND	shift, and go to state 67
    INLINE	shift, and go to state 70
    '}' 	shift, and go to state 107
    '~' 	shift, and go to state 72

    access_spec	go to state 73
    class_body_stmt	go to state 108
    class_constructor_decl	go to state 76
    class_destructor_decl	go to state 77
    func_decl	go to state 78
    storage_spec	go to state 79
    func_def	go to state 80
    func_def_inline	go to state 22
    func_def_normal	go to state 23
    func_def_common	go to state 24
    var_decl	go to state 81
    type	go to state 82
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 83



state 75

    class_body_stmts  ->  class_body_stmt .   (rule 25)

    $default	reduce using rule 25 (class_body_stmts)



state 76

    class_body_stmt  ->  class_constructor_decl .   (rule 31)

    $default	reduce using rule 31 (class_body_stmt)



state 77

    class_body_stmt  ->  class_destructor_decl .   (rule 32)

    $default	reduce using rule 32 (class_body_stmt)



state 78

    class_body_stmt  ->  func_decl .   (rule 28)

    $default	reduce using rule 28 (class_body_stmt)



state 79

    func_decl  ->  storage_spec . type ID_NAME '(' func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec . type ID_NAME '(' func_decl_args ')' CONST ';'   (rule 45)
    func_def_inline  ->  storage_spec . INLINE func_def_common   (rule 61)
    func_def_normal  ->  storage_spec . func_def_common   (rule 63)
    var_decl  ->  storage_spec . type var_list   (rule 86)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11
    INLINE	shift, and go to state 109

    func_def_common	go to state 50
    type	go to state 110
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 80

    class_body_stmt  ->  func_def .   (rule 29)

    $default	reduce using rule 29 (class_body_stmt)



state 81

    class_body_stmt  ->  var_decl . ';'   (rule 30)

    ';' 	shift, and go to state 111



state 82

    func_decl  ->  type . ID_NAME '(' func_decl_args ')' ';'   (rule 44)
    func_decl  ->  type . ID_NAME '(' func_decl_args ')' CONST ';'   (rule 46)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    var_decl  ->  type . var_list   (rule 87)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 55
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 59



state 83

    class_constructor_decl  ->  class_type . '(' func_decl_args ')' ';'   (rule 35)
    complex_type  ->  class_type .   (rule 154)

    '(' 	shift, and go to state 112

    $default	reduce using rule 154 (complex_type)



state 84

    func_def_inline  ->  storage_spec INLINE func_def_common .   (rule 61)

    $default	reduce using rule 61 (func_def_inline)



state 85

    class_func_def_inline  ->  storage_spec INLINE class_func_def_common .   (rule 69)

    $default	reduce using rule 69 (class_func_def_inline)



state 86

    func_decl  ->  storage_spec type ID_NAME . '(' func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec type ID_NAME . '(' func_decl_args ')' CONST ';'   (rule 45)
    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME . '(' func_decl_args ')' CONST block_stmt   (rule 66)
    var_list_elem  ->  ID_NAME .   (rule 88)
    var_list_elem  ->  ID_NAME . array_dims   (rule 89)
    var_list_elem  ->  ID_NAME . '=' expr   (rule 90)
    var_list_elem  ->  ID_NAME . array_dims '=' array_init_list   (rule 91)
    var_list  ->  ID_NAME . '(' proc_expr_list_not_empty ')'   (rule 94)

    '=' 	shift, and go to state 88
    '(' 	shift, and go to state 113
    '[' 	shift, and go to state 90

    $default	reduce using rule 88 (var_list_elem)

    array_dims	go to state 91
    array_dim	go to state 92



state 87

    var_decl  ->  storage_spec type var_list .   (rule 86)
    var_list  ->  var_list . ',' var_list_elem   (rule 93)

    ',' 	shift, and go to state 93

    $default	reduce using rule 86 (var_decl)



state 88

    var_list_elem  ->  ID_NAME '=' . expr   (rule 90)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 133
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 89

    func_decl  ->  type ID_NAME '(' . func_decl_args ')' ';'   (rule 44)
    func_decl  ->  type ID_NAME '(' . func_decl_args ')' CONST ';'   (rule 46)
    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' CONST block_stmt   (rule 66)
    var_list  ->  ID_NAME '(' . proc_expr_list_not_empty ')'   (rule 94)

    DOUBLE	shift, and go to state 4
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 145
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    proc_call	go to state 132
    proc_expr_list_not_empty	go to state 148
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 90

    array_dim  ->  '[' . ']'   (rule 97)
    array_dim  ->  '[' . INTEGER_CONST ']'   (rule 98)

    INTEGER_CONST	shift, and go to state 152
    ']' 	shift, and go to state 153



state 91

    var_list_elem  ->  ID_NAME array_dims .   (rule 89)
    var_list_elem  ->  ID_NAME array_dims . '=' array_init_list   (rule 91)
    array_dims  ->  array_dims . array_dim   (rule 96)

    '=' 	shift, and go to state 154
    '[' 	shift, and go to state 90

    $default	reduce using rule 89 (var_list_elem)

    array_dim	go to state 155



state 92

    array_dims  ->  array_dim .   (rule 95)

    $default	reduce using rule 95 (array_dims)



state 93

    var_list  ->  var_list ',' . var_list_elem   (rule 93)

    ID_NAME	shift, and go to state 156

    var_list_elem	go to state 157



state 94

    class_func_def_common  ->  type class_type SCOPE_DOTS . ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)
    class_static_init_var  ->  type class_type SCOPE_DOTS . ID_NAME '=' expr   (rule 105)

    ID_NAME	shift, and go to state 158



state 95

    class_destructor  ->  class_type SCOPE_DOTS '~' . class_type '(' ')' block_stmt   (rule 106)

    CLASS_ID	shift, and go to state 5

    class_type	go to state 159



state 96

    class_constructor  ->  class_type SCOPE_DOTS class_type . '(' func_decl_args ')' class_constructor_init_list block_stmt   (rule 36)

    '(' 	shift, and go to state 160



state 97

    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' CONST block_stmt   (rule 66)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 161
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 98

    class_func_def_common  ->  type class_type SCOPE_DOTS . ID_NAME '(' func_decl_args ')' block_stmt   (rule 73)

    ID_NAME	shift, and go to state 162



state 99

    class_def  ->  class_head ':' access_spec class_base_list . class_body   (rule 15)
    class_base_list  ->  class_base_list . ',' class_type   (rule 22)

    ',' 	shift, and go to state 163
    '{' 	shift, and go to state 47

    class_body	go to state 164



state 100

    class_base_list  ->  class_type .   (rule 21)

    $default	reduce using rule 21 (class_base_list)



state 101

    class_body_stmt  ->  error ';' .   (rule 33)

    $default	reduce using rule 33 (class_body_stmt)



state 102

    class_body_stmt  ->  error '}' .   (rule 34)

    $default	reduce using rule 34 (class_body_stmt)



state 103

    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 62
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57



state 104

    class_body  ->  '{' '}' ';' .   (rule 23)

    $default	reduce using rule 23 (class_body)



state 105

    class_destructor_decl  ->  '~' class_type . '(' ')' ';'   (rule 41)

    '(' 	shift, and go to state 165



state 106

    class_body_stmt  ->  access_spec ':' .   (rule 27)

    $default	reduce using rule 27 (class_body_stmt)



state 107

    class_body  ->  '{' class_body_stmts '}' . ';'   (rule 24)

    ';' 	shift, and go to state 166



state 108

    class_body_stmts  ->  class_body_stmts class_body_stmt .   (rule 26)

    $default	reduce using rule 26 (class_body_stmts)



state 109

    func_def_inline  ->  storage_spec INLINE . func_def_common   (rule 61)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    func_def_common	go to state 84
    type	go to state 103
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 110

    func_decl  ->  storage_spec type . ID_NAME '(' func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec type . ID_NAME '(' func_decl_args ')' CONST ';'   (rule 45)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type . ID_NAME '(' func_decl_args ')' CONST block_stmt   (rule 66)
    var_decl  ->  storage_spec type . var_list   (rule 86)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 86
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 87



state 111

    class_body_stmt  ->  var_decl ';' .   (rule 30)

    $default	reduce using rule 30 (class_body_stmt)



state 112

    class_constructor_decl  ->  class_type '(' . func_decl_args ')' ';'   (rule 35)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 167
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 113

    func_decl  ->  storage_spec type ID_NAME '(' . func_decl_args ')' ';'   (rule 43)
    func_decl  ->  storage_spec type ID_NAME '(' . func_decl_args ')' CONST ';'   (rule 45)
    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' . func_decl_args ')' CONST block_stmt   (rule 66)
    var_list  ->  ID_NAME '(' . proc_expr_list_not_empty ')'   (rule 94)

    DOUBLE	shift, and go to state 4
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 168
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    proc_call	go to state 132
    proc_expr_list_not_empty	go to state 148
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 114

    proc_call  ->  ID_NAME . '(' proc_expr_list ')'   (rule 112)
    proc_call  ->  ID_NAME . '.' ID_NAME '(' proc_expr_list ')'   (rule 113)
    var_expr  ->  ID_NAME .   (rule 173)
    var_expr  ->  ID_NAME . '.' var_expr   (rule 175)
    var_expr  ->  ID_NAME . ARROW ID_NAME   (rule 177)
    array_expr  ->  ID_NAME . array_expr_dims   (rule 179)

    '(' 	shift, and go to state 169
    ARROW	shift, and go to state 170
    '[' 	shift, and go to state 171
    '.' 	shift, and go to state 172

    $default	reduce using rule 173 (var_expr)

    array_expr_dims	go to state 173



state 115

    const_expr  ->  INTEGER_CONST .   (rule 165)

    $default	reduce using rule 165 (const_expr)



state 116

    const_expr  ->  DOUBLE_CONST .   (rule 166)

    $default	reduce using rule 166 (const_expr)



state 117

    const_expr  ->  STRING_CONST .   (rule 168)

    $default	reduce using rule 168 (const_expr)



state 118

    const_expr  ->  CHARACTER_CONST .   (rule 167)

    $default	reduce using rule 167 (const_expr)



state 119

    const_expr  ->  FALSE_CONST .   (rule 169)

    $default	reduce using rule 169 (const_expr)



state 120

    const_expr  ->  TRUE_CONST .   (rule 170)

    $default	reduce using rule 170 (const_expr)



state 121

    new_expr  ->  NEW . type '[' expr ']'   (rule 205)
    new_expr  ->  NEW . type '(' expr_list ')'   (rule 206)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    type	go to state 174
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 122

    delete_expr  ->  DELETE . var_expr   (rule 210)
    delete_expr  ->  DELETE . '[' ']' var_expr   (rule 211)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126
    '[' 	shift, and go to state 177

    var_expr	go to state 178
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 123

    proc_call  ->  THIS . ARROW proc_call   (rule 114)
    var_expr  ->  THIS .   (rule 174)
    var_expr  ->  THIS . ARROW var_expr   (rule 178)

    ARROW	shift, and go to state 180

    $default	reduce using rule 174 (var_expr)



state 124

    unary_expr  ->  '+' . expr   (rule 190)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 181
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 125

    unary_expr  ->  '-' . expr   (rule 184)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 182
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 126

    pointer_val_expr  ->  '*' . var_expr   (rule 182)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 183
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 127

    unary_expr  ->  '&' . var_expr   (rule 189)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 184
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 128

    unary_expr  ->  '!' . expr   (rule 183)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 185
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 129

    expr  ->  '(' . expr ')'   (rule 164)
    cast_expr  ->  '(' . type ')' var_expr   (rule 212)

    DOUBLE	shift, and go to state 4
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    type	go to state 186
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 187
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 130

    unary_expr  ->  ICR . expr   (rule 185)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 188
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 131

    unary_expr  ->  DECR . expr   (rule 187)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 189
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 132

    expr  ->  proc_call .   (rule 162)

    $default	reduce using rule 162 (expr)



state 133

    var_list_elem  ->  ID_NAME '=' expr .   (rule 90)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 90 (var_list_elem)



state 134

    expr  ->  const_expr .   (rule 157)

    $default	reduce using rule 157 (expr)



state 135

    expr  ->  var_expr .   (rule 158)

    $default	reduce using rule 158 (expr)



state 136

    var_expr  ->  array_expr .   (rule 171)

    $default	reduce using rule 171 (var_expr)



state 137

    var_expr  ->  pointer_val_expr .   (rule 172)

    $default	reduce using rule 172 (var_expr)



state 138

    expr  ->  unary_expr .   (rule 159)

    $default	reduce using rule 159 (expr)



state 139

    expr  ->  binary_expr .   (rule 160)

    $default	reduce using rule 160 (expr)



state 140

    expr  ->  allocate_expr .   (rule 161)

    $default	reduce using rule 161 (expr)



state 141

    allocate_expr  ->  new_expr .   (rule 203)

    $default	reduce using rule 203 (allocate_expr)



state 142

    allocate_expr  ->  delete_expr .   (rule 204)

    $default	reduce using rule 204 (allocate_expr)



state 143

    expr  ->  cast_expr .   (rule 163)

    $default	reduce using rule 163 (expr)



state 144

    proc_call  ->  class_type . SCOPE_DOTS ID_NAME '(' proc_expr_list ')'   (rule 115)
    var_expr  ->  class_type . SCOPE_DOTS ID_NAME   (rule 176)

    SCOPE_DOTS	shift, and go to state 204



state 145

    func_decl  ->  type ID_NAME '(' func_decl_args . ')' ';'   (rule 44)
    func_decl  ->  type ID_NAME '(' func_decl_args . ')' CONST ';'   (rule 46)
    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' CONST block_stmt   (rule 66)

    ')' 	shift, and go to state 205



state 146

    func_decl_args  ->  func_decl_arg_list .   (rule 53)
    func_decl_arg_list  ->  func_decl_arg_list . ',' func_decl_arg_elem   (rule 55)

    ',' 	shift, and go to state 206

    $default	reduce using rule 53 (func_decl_args)



state 147

    func_decl_arg_list  ->  func_decl_arg_elem .   (rule 54)

    $default	reduce using rule 54 (func_decl_arg_list)



state 148

    var_list  ->  ID_NAME '(' proc_expr_list_not_empty . ')'   (rule 94)
    proc_expr_list_not_empty  ->  proc_expr_list_not_empty . ',' expr   (rule 119)

    ')' 	shift, and go to state 207
    ',' 	shift, and go to state 208



state 149

    func_decl_arg_elem  ->  type .   (rule 56)
    func_decl_arg_elem  ->  type . ID_NAME   (rule 57)
    func_decl_arg_elem  ->  type . ID_NAME '=' const_expr   (rule 58)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 209
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    $default	reduce using rule 56 (func_decl_arg_elem)



state 150

    proc_expr_list_not_empty  ->  expr .   (rule 118)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 118 (proc_expr_list_not_empty)



state 151

    proc_call  ->  class_type . SCOPE_DOTS ID_NAME '(' proc_expr_list ')'   (rule 115)
    complex_type  ->  class_type .   (rule 154)
    var_expr  ->  class_type . SCOPE_DOTS ID_NAME   (rule 176)

    SCOPE_DOTS	shift, and go to state 204

    $default	reduce using rule 154 (complex_type)



state 152

    array_dim  ->  '[' INTEGER_CONST . ']'   (rule 98)

    ']' 	shift, and go to state 210



state 153

    array_dim  ->  '[' ']' .   (rule 97)

    $default	reduce using rule 97 (array_dim)



state 154

    var_list_elem  ->  ID_NAME array_dims '=' . array_init_list   (rule 91)

    '{' 	shift, and go to state 211

    array_init_list	go to state 212



state 155

    array_dims  ->  array_dims array_dim .   (rule 96)

    $default	reduce using rule 96 (array_dims)



state 156

    var_list_elem  ->  ID_NAME .   (rule 88)
    var_list_elem  ->  ID_NAME . array_dims   (rule 89)
    var_list_elem  ->  ID_NAME . '=' expr   (rule 90)
    var_list_elem  ->  ID_NAME . array_dims '=' array_init_list   (rule 91)

    '=' 	shift, and go to state 88
    '[' 	shift, and go to state 90

    $default	reduce using rule 88 (var_list_elem)

    array_dims	go to state 91
    array_dim	go to state 92



state 157

    var_list  ->  var_list ',' var_list_elem .   (rule 93)

    $default	reduce using rule 93 (var_list)



state 158

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME . '(' func_decl_args ')' block_stmt   (rule 73)
    class_static_init_var  ->  type class_type SCOPE_DOTS ID_NAME . '=' expr   (rule 105)

    '=' 	shift, and go to state 213
    '(' 	shift, and go to state 214



state 159

    class_destructor  ->  class_type SCOPE_DOTS '~' class_type . '(' ')' block_stmt   (rule 106)

    '(' 	shift, and go to state 215



state 160

    class_constructor  ->  class_type SCOPE_DOTS class_type '(' . func_decl_args ')' class_constructor_init_list block_stmt   (rule 36)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 216
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 161

    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' CONST block_stmt   (rule 66)

    ')' 	shift, and go to state 217



state 162

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME . '(' func_decl_args ')' block_stmt   (rule 73)

    '(' 	shift, and go to state 214



state 163

    class_base_list  ->  class_base_list ',' . class_type   (rule 22)

    CLASS_ID	shift, and go to state 5

    class_type	go to state 218



state 164

    class_def  ->  class_head ':' access_spec class_base_list class_body .   (rule 15)

    $default	reduce using rule 15 (class_def)



state 165

    class_destructor_decl  ->  '~' class_type '(' . ')' ';'   (rule 41)

    ')' 	shift, and go to state 219



state 166

    class_body  ->  '{' class_body_stmts '}' ';' .   (rule 24)

    $default	reduce using rule 24 (class_body)



state 167

    class_constructor_decl  ->  class_type '(' func_decl_args . ')' ';'   (rule 35)

    ')' 	shift, and go to state 220



state 168

    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args . ')' ';'   (rule 43)
    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args . ')' CONST ';'   (rule 45)
    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args . ')' CONST block_stmt   (rule 66)

    ')' 	shift, and go to state 221



state 169

    proc_call  ->  ID_NAME '(' . proc_expr_list ')'   (rule 112)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 116 (proc_expr_list)

    proc_call	go to state 132
    proc_expr_list	go to state 222
    proc_expr_list_not_empty	go to state 223
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 170

    var_expr  ->  ID_NAME ARROW . ID_NAME   (rule 177)

    ID_NAME	shift, and go to state 224



state 171

    array_expr_dims  ->  '[' . expr ']'   (rule 180)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 225
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 172

    proc_call  ->  ID_NAME '.' . ID_NAME '(' proc_expr_list ')'   (rule 113)
    var_expr  ->  ID_NAME '.' . var_expr   (rule 175)

    ID_NAME	shift, and go to state 226
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 227
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 173

    array_expr  ->  ID_NAME array_expr_dims .   (rule 179)
    array_expr_dims  ->  array_expr_dims . '[' expr ']'   (rule 181)

    '[' 	shift, and go to state 228

    $default	reduce using rule 179 (array_expr)



state 174

    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)
    new_expr  ->  NEW type . '[' expr ']'   (rule 205)
    new_expr  ->  NEW type . '(' expr_list ')'   (rule 206)

    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57
    '(' 	shift, and go to state 229
    '[' 	shift, and go to state 230



state 175

    var_expr  ->  ID_NAME .   (rule 173)
    var_expr  ->  ID_NAME . '.' var_expr   (rule 175)
    var_expr  ->  ID_NAME . ARROW ID_NAME   (rule 177)
    array_expr  ->  ID_NAME . array_expr_dims   (rule 179)

    ARROW	shift, and go to state 170
    '[' 	shift, and go to state 171
    '.' 	shift, and go to state 231

    $default	reduce using rule 173 (var_expr)

    array_expr_dims	go to state 173



state 176

    var_expr  ->  THIS .   (rule 174)
    var_expr  ->  THIS . ARROW var_expr   (rule 178)

    ARROW	shift, and go to state 232

    $default	reduce using rule 174 (var_expr)



state 177

    delete_expr  ->  DELETE '[' . ']' var_expr   (rule 211)

    ']' 	shift, and go to state 233



state 178

    delete_expr  ->  DELETE var_expr .   (rule 210)

    $default	reduce using rule 210 (delete_expr)



state 179

    var_expr  ->  class_type . SCOPE_DOTS ID_NAME   (rule 176)

    SCOPE_DOTS	shift, and go to state 234



state 180

    proc_call  ->  THIS ARROW . proc_call   (rule 114)
    var_expr  ->  THIS ARROW . var_expr   (rule 178)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 123
    '*' 	shift, and go to state 126

    proc_call	go to state 235
    var_expr	go to state 236
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 144



state 181

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    unary_expr  ->  '+' expr .   (rule 190)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)


    $default	reduce using rule 190 (unary_expr)



state 182

    unary_expr  ->  '-' expr .   (rule 184)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)


    $default	reduce using rule 184 (unary_expr)



state 183

    pointer_val_expr  ->  '*' var_expr .   (rule 182)

    $default	reduce using rule 182 (pointer_val_expr)



state 184

    unary_expr  ->  '&' var_expr .   (rule 189)

    $default	reduce using rule 189 (unary_expr)



state 185

    unary_expr  ->  '!' expr .   (rule 183)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)


    $default	reduce using rule 183 (unary_expr)



state 186

    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)
    cast_expr  ->  '(' type . ')' var_expr   (rule 212)

    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57
    ')' 	shift, and go to state 237



state 187

    expr  ->  '(' expr . ')'   (rule 164)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ')' 	shift, and go to state 238
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203



state 188

    unary_expr  ->  ICR expr .   (rule 185)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)


    $default	reduce using rule 185 (unary_expr)



state 189

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  DECR expr .   (rule 187)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)


    $default	reduce using rule 187 (unary_expr)



state 190

    binary_expr  ->  expr LE . expr   (rule 197)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 239
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 191

    binary_expr  ->  expr GE . expr   (rule 198)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 240
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 192

    binary_expr  ->  expr EQ . expr   (rule 199)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 241
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 193

    binary_expr  ->  expr NE . expr   (rule 200)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 242
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 194

    binary_expr  ->  expr '<' . expr   (rule 195)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 243
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 195

    binary_expr  ->  expr '>' . expr   (rule 196)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 244
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 196

    binary_expr  ->  expr '+' . expr   (rule 191)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 245
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 197

    binary_expr  ->  expr '-' . expr   (rule 192)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 246
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 198

    binary_expr  ->  expr ANDAND . expr   (rule 202)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 247
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 199

    binary_expr  ->  expr OROR . expr   (rule 201)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 248
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 200

    binary_expr  ->  expr '*' . expr   (rule 194)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 249
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 201

    binary_expr  ->  expr '/' . expr   (rule 193)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 250
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 202

    unary_expr  ->  expr ICR .   (rule 186)

    $default	reduce using rule 186 (unary_expr)



state 203

    unary_expr  ->  expr DECR .   (rule 188)

    $default	reduce using rule 188 (unary_expr)



state 204

    proc_call  ->  class_type SCOPE_DOTS . ID_NAME '(' proc_expr_list ')'   (rule 115)
    var_expr  ->  class_type SCOPE_DOTS . ID_NAME   (rule 176)

    ID_NAME	shift, and go to state 251



state 205

    func_decl  ->  type ID_NAME '(' func_decl_args ')' . ';'   (rule 44)
    func_decl  ->  type ID_NAME '(' func_decl_args ')' . CONST ';'   (rule 46)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . CONST block_stmt   (rule 66)

    CONST	shift, and go to state 252
    ';' 	shift, and go to state 253
    '{' 	shift, and go to state 254

    block_stmt	go to state 255



state 206

    func_decl_arg_list  ->  func_decl_arg_list ',' . func_decl_arg_elem   (rule 55)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    func_decl_arg_elem	go to state 256
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 207

    var_list  ->  ID_NAME '(' proc_expr_list_not_empty ')' .   (rule 94)

    $default	reduce using rule 94 (var_list)



state 208

    proc_expr_list_not_empty  ->  proc_expr_list_not_empty ',' . expr   (rule 119)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 257
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 209

    func_decl_arg_elem  ->  type ID_NAME .   (rule 57)
    func_decl_arg_elem  ->  type ID_NAME . '=' const_expr   (rule 58)

    '=' 	shift, and go to state 258

    $default	reduce using rule 57 (func_decl_arg_elem)



state 210

    array_dim  ->  '[' INTEGER_CONST ']' .   (rule 98)

    $default	reduce using rule 98 (array_dim)



state 211

    array_init_list  ->  '{' . array_init_list_consts '}'   (rule 99)
    array_init_list  ->  '{' . array_init_list_lists '}'   (rule 100)

    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    '{' 	shift, and go to state 211

    array_init_list	go to state 259
    array_init_list_consts	go to state 260
    array_init_list_lists	go to state 261
    const_expr	go to state 262



state 212

    var_list_elem  ->  ID_NAME array_dims '=' array_init_list .   (rule 91)

    $default	reduce using rule 91 (var_list_elem)



state 213

    class_static_init_var  ->  type class_type SCOPE_DOTS ID_NAME '=' . expr   (rule 105)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 263
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 214

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME '(' . func_decl_args ')' block_stmt   (rule 73)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    $default	reduce using rule 52 (func_decl_args)

    func_decl_args	go to state 264
    func_decl_arg_list	go to state 146
    func_decl_arg_elem	go to state 147
    type	go to state 149
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 215

    class_destructor  ->  class_type SCOPE_DOTS '~' class_type '(' . ')' block_stmt   (rule 106)

    ')' 	shift, and go to state 265



state 216

    class_constructor  ->  class_type SCOPE_DOTS class_type '(' func_decl_args . ')' class_constructor_init_list block_stmt   (rule 36)

    ')' 	shift, and go to state 266



state 217

    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . CONST block_stmt   (rule 66)

    CONST	shift, and go to state 267
    '{' 	shift, and go to state 254

    block_stmt	go to state 255



state 218

    class_base_list  ->  class_base_list ',' class_type .   (rule 22)

    $default	reduce using rule 22 (class_base_list)



state 219

    class_destructor_decl  ->  '~' class_type '(' ')' . ';'   (rule 41)

    ';' 	shift, and go to state 268



state 220

    class_constructor_decl  ->  class_type '(' func_decl_args ')' . ';'   (rule 35)

    ';' 	shift, and go to state 269



state 221

    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args ')' . ';'   (rule 43)
    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args ')' . CONST ';'   (rule 45)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . block_stmt   (rule 65)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' . CONST block_stmt   (rule 66)

    CONST	shift, and go to state 270
    ';' 	shift, and go to state 271
    '{' 	shift, and go to state 254

    block_stmt	go to state 255



state 222

    proc_call  ->  ID_NAME '(' proc_expr_list . ')'   (rule 112)

    ')' 	shift, and go to state 272



state 223

    proc_expr_list  ->  proc_expr_list_not_empty .   (rule 117)
    proc_expr_list_not_empty  ->  proc_expr_list_not_empty . ',' expr   (rule 119)

    ',' 	shift, and go to state 208

    $default	reduce using rule 117 (proc_expr_list)



state 224

    var_expr  ->  ID_NAME ARROW ID_NAME .   (rule 177)

    $default	reduce using rule 177 (var_expr)



state 225

    array_expr_dims  ->  '[' expr . ']'   (rule 180)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203
    ']' 	shift, and go to state 273



state 226

    proc_call  ->  ID_NAME '.' ID_NAME . '(' proc_expr_list ')'   (rule 113)
    var_expr  ->  ID_NAME .   (rule 173)
    var_expr  ->  ID_NAME . '.' var_expr   (rule 175)
    var_expr  ->  ID_NAME . ARROW ID_NAME   (rule 177)
    array_expr  ->  ID_NAME . array_expr_dims   (rule 179)

    '(' 	shift, and go to state 274
    ARROW	shift, and go to state 170
    '[' 	shift, and go to state 171
    '.' 	shift, and go to state 231

    $default	reduce using rule 173 (var_expr)

    array_expr_dims	go to state 173



state 227

    var_expr  ->  ID_NAME '.' var_expr .   (rule 175)

    $default	reduce using rule 175 (var_expr)



state 228

    array_expr_dims  ->  array_expr_dims '[' . expr ']'   (rule 181)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 275
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 229

    new_expr  ->  NEW type '(' . expr_list ')'   (rule 206)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 207 (expr_list)

    proc_call	go to state 132
    expr	go to state 276
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    expr_list	go to state 277
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 230

    new_expr  ->  NEW type '[' . expr ']'   (rule 205)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 278
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 231

    var_expr  ->  ID_NAME '.' . var_expr   (rule 175)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 227
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 232

    var_expr  ->  THIS ARROW . var_expr   (rule 178)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 236
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 233

    delete_expr  ->  DELETE '[' ']' . var_expr   (rule 211)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 279
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 234

    var_expr  ->  class_type SCOPE_DOTS . ID_NAME   (rule 176)

    ID_NAME	shift, and go to state 280



state 235

    proc_call  ->  THIS ARROW proc_call .   (rule 114)

    $default	reduce using rule 114 (proc_call)



state 236

    var_expr  ->  THIS ARROW var_expr .   (rule 178)

    $default	reduce using rule 178 (var_expr)



state 237

    cast_expr  ->  '(' type ')' . var_expr   (rule 212)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 281
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 238

    expr  ->  '(' expr ')' .   (rule 164)

    $default	reduce using rule 164 (expr)



state 239

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr LE expr .   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 197 (binary_expr)



state 240

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr GE expr .   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 198 (binary_expr)



state 241

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr EQ expr .   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 199 (binary_expr)



state 242

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr NE expr .   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 200 (binary_expr)



state 243

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr '<' expr .   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 195 (binary_expr)



state 244

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr '>' expr .   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 196 (binary_expr)



state 245

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr '+' expr .   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 191 (binary_expr)



state 246

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr '-' expr .   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 192 (binary_expr)



state 247

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)
    binary_expr  ->  expr ANDAND expr .   (rule 202)

    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 202 (binary_expr)



state 248

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr OROR expr .   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 201 (binary_expr)



state 249

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr '*' expr .   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 194 (binary_expr)



state 250

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr '/' expr .   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 193 (binary_expr)



state 251

    proc_call  ->  class_type SCOPE_DOTS ID_NAME . '(' proc_expr_list ')'   (rule 115)
    var_expr  ->  class_type SCOPE_DOTS ID_NAME .   (rule 176)

    '(' 	shift, and go to state 282

    $default	reduce using rule 176 (var_expr)



state 252

    func_decl  ->  type ID_NAME '(' func_decl_args ')' CONST . ';'   (rule 46)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' CONST . block_stmt   (rule 66)

    ';' 	shift, and go to state 283
    '{' 	shift, and go to state 254

    block_stmt	go to state 284



state 253

    func_decl  ->  type ID_NAME '(' func_decl_args ')' ';' .   (rule 44)

    $default	reduce using rule 44 (func_decl)



state 254

    block_stmt  ->  '{' . '}'   (rule 135)
    block_stmt  ->  '{' . stmts '}'   (rule 136)

    error	shift, and go to state 285
    EXTERN	shift, and go to state 3
    CIN 	shift, and go to state 286
    BREAK	shift, and go to state 287
    COUT	shift, and go to state 288
    FOR 	shift, and go to state 289
    DOUBLE	shift, and go to state 4
    RETURN	shift, and go to state 290
    WHILE	shift, and go to state 291
    CONTINUE	shift, and go to state 292
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131
    IF  	shift, and go to state 293
    '{' 	shift, and go to state 254
    '}' 	shift, and go to state 294

    storage_spec	go to state 295
    stmts	go to state 296
    stmt	go to state 297
    simple_stmt	go to state 298
    var_decl	go to state 299
    assignment	go to state 300
    proc_call	go to state 132
    jump_stmt	go to state 301
    cin_stmt	go to state 302
    cout_stmt	go to state 303
    compound_stmt	go to state 304
    block_stmt	go to state 305
    if_stmt	go to state 306
    for_stmt	go to state 307
    while_stmt	go to state 308
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 310
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 255

    func_def_common  ->  type ID_NAME '(' func_decl_args ')' block_stmt .   (rule 65)

    $default	reduce using rule 65 (func_def_common)



state 256

    func_decl_arg_list  ->  func_decl_arg_list ',' func_decl_arg_elem .   (rule 55)

    $default	reduce using rule 55 (func_decl_arg_list)



state 257

    proc_expr_list_not_empty  ->  proc_expr_list_not_empty ',' expr .   (rule 119)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 119 (proc_expr_list_not_empty)



state 258

    func_decl_arg_elem  ->  type ID_NAME '=' . const_expr   (rule 58)

    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120

    const_expr	go to state 312



state 259

    array_init_list_lists  ->  array_init_list .   (rule 103)

    $default	reduce using rule 103 (array_init_list_lists)



state 260

    array_init_list  ->  '{' array_init_list_consts . '}'   (rule 99)
    array_init_list_consts  ->  array_init_list_consts . ',' const_expr   (rule 102)

    ',' 	shift, and go to state 313
    '}' 	shift, and go to state 314



state 261

    array_init_list  ->  '{' array_init_list_lists . '}'   (rule 100)
    array_init_list_lists  ->  array_init_list_lists . ',' array_init_list   (rule 104)

    ',' 	shift, and go to state 315
    '}' 	shift, and go to state 316



state 262

    array_init_list_consts  ->  const_expr .   (rule 101)

    $default	reduce using rule 101 (array_init_list_consts)



state 263

    class_static_init_var  ->  type class_type SCOPE_DOTS ID_NAME '=' expr .   (rule 105)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 105 (class_static_init_var)



state 264

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME '(' func_decl_args . ')' block_stmt   (rule 73)

    ')' 	shift, and go to state 317



state 265

    class_destructor  ->  class_type SCOPE_DOTS '~' class_type '(' ')' . block_stmt   (rule 106)

    '{' 	shift, and go to state 254

    block_stmt	go to state 318



state 266

    class_constructor  ->  class_type SCOPE_DOTS class_type '(' func_decl_args ')' . class_constructor_init_list block_stmt   (rule 36)

    ':' 	shift, and go to state 319

    $default	reduce using rule 37 (class_constructor_init_list)

    class_constructor_init_list	go to state 320



state 267

    func_def_common  ->  type ID_NAME '(' func_decl_args ')' CONST . block_stmt   (rule 66)

    '{' 	shift, and go to state 254

    block_stmt	go to state 284



state 268

    class_destructor_decl  ->  '~' class_type '(' ')' ';' .   (rule 41)

    $default	reduce using rule 41 (class_destructor_decl)



state 269

    class_constructor_decl  ->  class_type '(' func_decl_args ')' ';' .   (rule 35)

    $default	reduce using rule 35 (class_constructor_decl)



state 270

    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args ')' CONST . ';'   (rule 45)
    func_def_common  ->  type ID_NAME '(' func_decl_args ')' CONST . block_stmt   (rule 66)

    ';' 	shift, and go to state 321
    '{' 	shift, and go to state 254

    block_stmt	go to state 284



state 271

    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args ')' ';' .   (rule 43)

    $default	reduce using rule 43 (func_decl)



state 272

    proc_call  ->  ID_NAME '(' proc_expr_list ')' .   (rule 112)

    $default	reduce using rule 112 (proc_call)



state 273

    array_expr_dims  ->  '[' expr ']' .   (rule 180)

    $default	reduce using rule 180 (array_expr_dims)



state 274

    proc_call  ->  ID_NAME '.' ID_NAME '(' . proc_expr_list ')'   (rule 113)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 116 (proc_expr_list)

    proc_call	go to state 132
    proc_expr_list	go to state 322
    proc_expr_list_not_empty	go to state 223
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 275

    array_expr_dims  ->  array_expr_dims '[' expr . ']'   (rule 181)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203
    ']' 	shift, and go to state 323



state 276

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)
    expr_list  ->  expr .   (rule 208)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 208 (expr_list)



state 277

    new_expr  ->  NEW type '(' expr_list . ')'   (rule 206)
    expr_list  ->  expr_list . ',' expr   (rule 209)

    ')' 	shift, and go to state 324
    ',' 	shift, and go to state 325



state 278

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)
    new_expr  ->  NEW type '[' expr . ']'   (rule 205)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203
    ']' 	shift, and go to state 326



state 279

    delete_expr  ->  DELETE '[' ']' var_expr .   (rule 211)

    $default	reduce using rule 211 (delete_expr)



state 280

    var_expr  ->  class_type SCOPE_DOTS ID_NAME .   (rule 176)

    $default	reduce using rule 176 (var_expr)



state 281

    cast_expr  ->  '(' type ')' var_expr .   (rule 212)

    $default	reduce using rule 212 (cast_expr)



state 282

    proc_call  ->  class_type SCOPE_DOTS ID_NAME '(' . proc_expr_list ')'   (rule 115)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    $default	reduce using rule 116 (proc_expr_list)

    proc_call	go to state 132
    proc_expr_list	go to state 327
    proc_expr_list_not_empty	go to state 223
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 283

    func_decl  ->  type ID_NAME '(' func_decl_args ')' CONST ';' .   (rule 46)

    $default	reduce using rule 46 (func_decl)



state 284

    func_def_common  ->  type ID_NAME '(' func_decl_args ')' CONST block_stmt .   (rule 66)

    $default	reduce using rule 66 (func_def_common)



state 285

    stmt  ->  error . ';'   (rule 78)
    stmt  ->  error . '}'   (rule 79)

    ';' 	shift, and go to state 328
    '}' 	shift, and go to state 329



state 286

    cin_stmt  ->  CIN . cin_stmt_input_list   (rule 123)

    INPUT_VAR_SYM	shift, and go to state 330

    cin_stmt_input_list	go to state 331
    input_elem	go to state 332



state 287

    jump_stmt  ->  BREAK .   (rule 120)

    $default	reduce using rule 120 (jump_stmt)



state 288

    cout_stmt  ->  COUT . cout_stmt_output_list   (rule 127)

    OUTPUT_VAR_SYM	shift, and go to state 333

    cout_stmt_output_list	go to state 334
    output_elem	go to state 335



state 289

    for_stmt  ->  FOR . '(' var_decl ';' expr ';' for_itr ')' block_stmt   (rule 139)

    '(' 	shift, and go to state 336



state 290

    jump_stmt  ->  RETURN . expr   (rule 121)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 337
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 291

    while_stmt  ->  WHILE . '(' expr ')' stmt   (rule 144)

    '(' 	shift, and go to state 338



state 292

    jump_stmt  ->  CONTINUE .   (rule 122)

    $default	reduce using rule 122 (jump_stmt)



state 293

    if_stmt  ->  IF . '(' expr ')' stmt   (rule 137)
    if_stmt  ->  IF . '(' expr ')' stmt ELSE stmt   (rule 138)

    '(' 	shift, and go to state 339



state 294

    block_stmt  ->  '{' '}' .   (rule 135)

    $default	reduce using rule 135 (block_stmt)



state 295

    var_decl  ->  storage_spec . type var_list   (rule 86)

    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    VOID	shift, and go to state 11

    type	go to state 340
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 296

    stmts  ->  stmts . stmt   (rule 75)
    block_stmt  ->  '{' stmts . '}'   (rule 136)

    error	shift, and go to state 285
    EXTERN	shift, and go to state 3
    CIN 	shift, and go to state 286
    BREAK	shift, and go to state 287
    COUT	shift, and go to state 288
    FOR 	shift, and go to state 289
    DOUBLE	shift, and go to state 4
    RETURN	shift, and go to state 290
    WHILE	shift, and go to state 291
    CONTINUE	shift, and go to state 292
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131
    IF  	shift, and go to state 293
    '{' 	shift, and go to state 254
    '}' 	shift, and go to state 341

    storage_spec	go to state 295
    stmt	go to state 342
    simple_stmt	go to state 298
    var_decl	go to state 299
    assignment	go to state 300
    proc_call	go to state 132
    jump_stmt	go to state 301
    cin_stmt	go to state 302
    cout_stmt	go to state 303
    compound_stmt	go to state 304
    block_stmt	go to state 305
    if_stmt	go to state 306
    for_stmt	go to state 307
    while_stmt	go to state 308
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 310
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 297

    stmts  ->  stmt .   (rule 74)

    $default	reduce using rule 74 (stmts)



state 298

    stmt  ->  simple_stmt . ';'   (rule 76)

    ';' 	shift, and go to state 343



state 299

    simple_stmt  ->  var_decl .   (rule 80)

    $default	reduce using rule 80 (simple_stmt)



state 300

    simple_stmt  ->  assignment .   (rule 81)

    $default	reduce using rule 81 (simple_stmt)



state 301

    simple_stmt  ->  jump_stmt .   (rule 83)

    $default	reduce using rule 83 (simple_stmt)



state 302

    simple_stmt  ->  cin_stmt .   (rule 84)

    $default	reduce using rule 84 (simple_stmt)



state 303

    simple_stmt  ->  cout_stmt .   (rule 85)

    $default	reduce using rule 85 (simple_stmt)



state 304

    stmt  ->  compound_stmt .   (rule 77)

    $default	reduce using rule 77 (stmt)



state 305

    compound_stmt  ->  block_stmt .   (rule 134)

    $default	reduce using rule 134 (compound_stmt)



state 306

    compound_stmt  ->  if_stmt .   (rule 131)

    $default	reduce using rule 131 (compound_stmt)



state 307

    compound_stmt  ->  for_stmt .   (rule 132)

    $default	reduce using rule 132 (compound_stmt)



state 308

    compound_stmt  ->  while_stmt .   (rule 133)

    $default	reduce using rule 133 (compound_stmt)



state 309

    var_decl  ->  type . var_list   (rule 87)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 344
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 59



state 310

    simple_stmt  ->  expr .   (rule 82)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 82 (simple_stmt)



state 311

    assignment  ->  var_expr . '=' expr   (rule 107)
    assignment  ->  var_expr . PLUS_EQ expr   (rule 108)
    assignment  ->  var_expr . MINUS_EQ expr   (rule 109)
    assignment  ->  var_expr . DIV_EQ expr   (rule 110)
    assignment  ->  var_expr . MULT_EQ expr   (rule 111)
    expr  ->  var_expr .   (rule 158)

    PLUS_EQ	shift, and go to state 345
    MULT_EQ	shift, and go to state 346
    MINUS_EQ	shift, and go to state 347
    DIV_EQ	shift, and go to state 348
    '=' 	shift, and go to state 349

    $default	reduce using rule 158 (expr)



state 312

    func_decl_arg_elem  ->  type ID_NAME '=' const_expr .   (rule 58)

    $default	reduce using rule 58 (func_decl_arg_elem)



state 313

    array_init_list_consts  ->  array_init_list_consts ',' . const_expr   (rule 102)

    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120

    const_expr	go to state 350



state 314

    array_init_list  ->  '{' array_init_list_consts '}' .   (rule 99)

    $default	reduce using rule 99 (array_init_list)



state 315

    array_init_list_lists  ->  array_init_list_lists ',' . array_init_list   (rule 104)

    '{' 	shift, and go to state 211

    array_init_list	go to state 351



state 316

    array_init_list  ->  '{' array_init_list_lists '}' .   (rule 100)

    $default	reduce using rule 100 (array_init_list)



state 317

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' . block_stmt   (rule 73)

    '{' 	shift, and go to state 254

    block_stmt	go to state 352



state 318

    class_destructor  ->  class_type SCOPE_DOTS '~' class_type '(' ')' block_stmt .   (rule 106)

    $default	reduce using rule 106 (class_destructor)



state 319

    class_constructor_init_list  ->  ':' . c_c_init_list   (rule 38)

    ID_NAME	shift, and go to state 353

    c_c_init_list	go to state 354



state 320

    class_constructor  ->  class_type SCOPE_DOTS class_type '(' func_decl_args ')' class_constructor_init_list . block_stmt   (rule 36)

    '{' 	shift, and go to state 254

    block_stmt	go to state 355



state 321

    func_decl  ->  storage_spec type ID_NAME '(' func_decl_args ')' CONST ';' .   (rule 45)

    $default	reduce using rule 45 (func_decl)



state 322

    proc_call  ->  ID_NAME '.' ID_NAME '(' proc_expr_list . ')'   (rule 113)

    ')' 	shift, and go to state 356



state 323

    array_expr_dims  ->  array_expr_dims '[' expr ']' .   (rule 181)

    $default	reduce using rule 181 (array_expr_dims)



state 324

    new_expr  ->  NEW type '(' expr_list ')' .   (rule 206)

    $default	reduce using rule 206 (new_expr)



state 325

    expr_list  ->  expr_list ',' . expr   (rule 209)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 357
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 326

    new_expr  ->  NEW type '[' expr ']' .   (rule 205)

    $default	reduce using rule 205 (new_expr)



state 327

    proc_call  ->  class_type SCOPE_DOTS ID_NAME '(' proc_expr_list . ')'   (rule 115)

    ')' 	shift, and go to state 358



state 328

    stmt  ->  error ';' .   (rule 78)

    $default	reduce using rule 78 (stmt)



state 329

    stmt  ->  error '}' .   (rule 79)

    $default	reduce using rule 79 (stmt)



state 330

    input_elem  ->  INPUT_VAR_SYM . var_expr   (rule 126)

    ID_NAME	shift, and go to state 175
    CLASS_ID	shift, and go to state 5
    THIS	shift, and go to state 176
    '*' 	shift, and go to state 126

    var_expr	go to state 359
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    class_type	go to state 179



state 331

    cin_stmt  ->  CIN cin_stmt_input_list .   (rule 123)
    cin_stmt_input_list  ->  cin_stmt_input_list . input_elem   (rule 125)

    INPUT_VAR_SYM	shift, and go to state 330

    $default	reduce using rule 123 (cin_stmt)

    input_elem	go to state 360



state 332

    cin_stmt_input_list  ->  input_elem .   (rule 124)

    $default	reduce using rule 124 (cin_stmt_input_list)



state 333

    output_elem  ->  OUTPUT_VAR_SYM . expr   (rule 130)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 361
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 334

    cout_stmt  ->  COUT cout_stmt_output_list .   (rule 127)
    cout_stmt_output_list  ->  cout_stmt_output_list . output_elem   (rule 129)

    OUTPUT_VAR_SYM	shift, and go to state 333

    $default	reduce using rule 127 (cout_stmt)

    output_elem	go to state 362



state 335

    cout_stmt_output_list  ->  output_elem .   (rule 128)

    $default	reduce using rule 128 (cout_stmt_output_list)



state 336

    for_stmt  ->  FOR '(' . var_decl ';' expr ';' for_itr ')' block_stmt   (rule 139)

    EXTERN	shift, and go to state 3
    DOUBLE	shift, and go to state 4
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    VOID	shift, and go to state 11

    storage_spec	go to state 295
    var_decl	go to state 363
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    class_type	go to state 44



state 337

    jump_stmt  ->  RETURN expr .   (rule 121)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 121 (jump_stmt)



state 338

    while_stmt  ->  WHILE '(' . expr ')' stmt   (rule 144)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 364
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 339

    if_stmt  ->  IF '(' . expr ')' stmt   (rule 137)
    if_stmt  ->  IF '(' . expr ')' stmt ELSE stmt   (rule 138)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 365
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 340

    var_decl  ->  storage_spec type . var_list   (rule 86)
    pointer_type  ->  type . '*'   (rule 155)
    reference_type  ->  type . '&'   (rule 156)

    ID_NAME	shift, and go to state 344
    '*' 	shift, and go to state 56
    '&' 	shift, and go to state 57

    var_list_elem	go to state 58
    var_list	go to state 87



state 341

    block_stmt  ->  '{' stmts '}' .   (rule 136)

    $default	reduce using rule 136 (block_stmt)



state 342

    stmts  ->  stmts stmt .   (rule 75)

    $default	reduce using rule 75 (stmts)



state 343

    stmt  ->  simple_stmt ';' .   (rule 76)

    $default	reduce using rule 76 (stmt)



state 344

    var_list_elem  ->  ID_NAME .   (rule 88)
    var_list_elem  ->  ID_NAME . array_dims   (rule 89)
    var_list_elem  ->  ID_NAME . '=' expr   (rule 90)
    var_list_elem  ->  ID_NAME . array_dims '=' array_init_list   (rule 91)
    var_list  ->  ID_NAME . '(' proc_expr_list_not_empty ')'   (rule 94)

    '=' 	shift, and go to state 88
    '(' 	shift, and go to state 366
    '[' 	shift, and go to state 90

    $default	reduce using rule 88 (var_list_elem)

    array_dims	go to state 91
    array_dim	go to state 92



state 345

    assignment  ->  var_expr PLUS_EQ . expr   (rule 108)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 367
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 346

    assignment  ->  var_expr MULT_EQ . expr   (rule 111)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 368
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 347

    assignment  ->  var_expr MINUS_EQ . expr   (rule 109)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 369
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 348

    assignment  ->  var_expr DIV_EQ . expr   (rule 110)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 370
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 349

    assignment  ->  var_expr '=' . expr   (rule 107)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 371
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 350

    array_init_list_consts  ->  array_init_list_consts ',' const_expr .   (rule 102)

    $default	reduce using rule 102 (array_init_list_consts)



state 351

    array_init_list_lists  ->  array_init_list_lists ',' array_init_list .   (rule 104)

    $default	reduce using rule 104 (array_init_list_lists)



state 352

    class_func_def_common  ->  type class_type SCOPE_DOTS ID_NAME '(' func_decl_args ')' block_stmt .   (rule 73)

    $default	reduce using rule 73 (class_func_def_common)



state 353

    c_c_init_list  ->  ID_NAME . '(' const_expr ')'   (rule 39)

    '(' 	shift, and go to state 372



state 354

    class_constructor_init_list  ->  ':' c_c_init_list .   (rule 38)
    c_c_init_list  ->  c_c_init_list . ',' ID_NAME '(' expr ')'   (rule 40)

    ',' 	shift, and go to state 373

    $default	reduce using rule 38 (class_constructor_init_list)



state 355

    class_constructor  ->  class_type SCOPE_DOTS class_type '(' func_decl_args ')' class_constructor_init_list block_stmt .   (rule 36)

    $default	reduce using rule 36 (class_constructor)



state 356

    proc_call  ->  ID_NAME '.' ID_NAME '(' proc_expr_list ')' .   (rule 113)

    $default	reduce using rule 113 (proc_call)



state 357

    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)
    expr_list  ->  expr_list ',' expr .   (rule 209)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 209 (expr_list)



state 358

    proc_call  ->  class_type SCOPE_DOTS ID_NAME '(' proc_expr_list ')' .   (rule 115)

    $default	reduce using rule 115 (proc_call)



state 359

    input_elem  ->  INPUT_VAR_SYM var_expr .   (rule 126)

    $default	reduce using rule 126 (input_elem)



state 360

    cin_stmt_input_list  ->  cin_stmt_input_list input_elem .   (rule 125)

    $default	reduce using rule 125 (cin_stmt_input_list)



state 361

    output_elem  ->  OUTPUT_VAR_SYM expr .   (rule 130)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 130 (output_elem)



state 362

    cout_stmt_output_list  ->  cout_stmt_output_list output_elem .   (rule 129)

    $default	reduce using rule 129 (cout_stmt_output_list)



state 363

    for_stmt  ->  FOR '(' var_decl . ';' expr ';' for_itr ')' block_stmt   (rule 139)

    ';' 	shift, and go to state 374



state 364

    while_stmt  ->  WHILE '(' expr . ')' stmt   (rule 144)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ')' 	shift, and go to state 375
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203



state 365

    if_stmt  ->  IF '(' expr . ')' stmt   (rule 137)
    if_stmt  ->  IF '(' expr . ')' stmt ELSE stmt   (rule 138)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ')' 	shift, and go to state 376
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203



state 366

    var_list  ->  ID_NAME '(' . proc_expr_list_not_empty ')'   (rule 94)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    proc_expr_list_not_empty	go to state 148
    expr	go to state 150
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 367

    assignment  ->  var_expr PLUS_EQ expr .   (rule 108)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 108 (assignment)



state 368

    assignment  ->  var_expr MULT_EQ expr .   (rule 111)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 111 (assignment)



state 369

    assignment  ->  var_expr MINUS_EQ expr .   (rule 109)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 109 (assignment)



state 370

    assignment  ->  var_expr DIV_EQ expr .   (rule 110)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 110 (assignment)



state 371

    assignment  ->  var_expr '=' expr .   (rule 107)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 107 (assignment)



state 372

    c_c_init_list  ->  ID_NAME '(' . const_expr ')'   (rule 39)

    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120

    const_expr	go to state 377



state 373

    c_c_init_list  ->  c_c_init_list ',' . ID_NAME '(' expr ')'   (rule 40)

    ID_NAME	shift, and go to state 378



state 374

    for_stmt  ->  FOR '(' var_decl ';' . expr ';' for_itr ')' block_stmt   (rule 139)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 379
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 375

    while_stmt  ->  WHILE '(' expr ')' . stmt   (rule 144)

    error	shift, and go to state 285
    EXTERN	shift, and go to state 3
    CIN 	shift, and go to state 286
    BREAK	shift, and go to state 287
    COUT	shift, and go to state 288
    FOR 	shift, and go to state 289
    DOUBLE	shift, and go to state 4
    RETURN	shift, and go to state 290
    WHILE	shift, and go to state 291
    CONTINUE	shift, and go to state 292
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131
    IF  	shift, and go to state 293
    '{' 	shift, and go to state 254

    storage_spec	go to state 295
    stmt	go to state 380
    simple_stmt	go to state 298
    var_decl	go to state 299
    assignment	go to state 300
    proc_call	go to state 132
    jump_stmt	go to state 301
    cin_stmt	go to state 302
    cout_stmt	go to state 303
    compound_stmt	go to state 304
    block_stmt	go to state 305
    if_stmt	go to state 306
    for_stmt	go to state 307
    while_stmt	go to state 308
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 310
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 376

    if_stmt  ->  IF '(' expr ')' . stmt   (rule 137)
    if_stmt  ->  IF '(' expr ')' . stmt ELSE stmt   (rule 138)

    error	shift, and go to state 285
    EXTERN	shift, and go to state 3
    CIN 	shift, and go to state 286
    BREAK	shift, and go to state 287
    COUT	shift, and go to state 288
    FOR 	shift, and go to state 289
    DOUBLE	shift, and go to state 4
    RETURN	shift, and go to state 290
    WHILE	shift, and go to state 291
    CONTINUE	shift, and go to state 292
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131
    IF  	shift, and go to state 293
    '{' 	shift, and go to state 254

    storage_spec	go to state 295
    stmt	go to state 381
    simple_stmt	go to state 298
    var_decl	go to state 299
    assignment	go to state 300
    proc_call	go to state 132
    jump_stmt	go to state 301
    cin_stmt	go to state 302
    cout_stmt	go to state 303
    compound_stmt	go to state 304
    block_stmt	go to state 305
    if_stmt	go to state 306
    for_stmt	go to state 307
    while_stmt	go to state 308
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 310
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 377

    c_c_init_list  ->  ID_NAME '(' const_expr . ')'   (rule 39)

    ')' 	shift, and go to state 382



state 378

    c_c_init_list  ->  c_c_init_list ',' ID_NAME . '(' expr ')'   (rule 40)

    '(' 	shift, and go to state 383



state 379

    for_stmt  ->  FOR '(' var_decl ';' expr . ';' for_itr ')' block_stmt   (rule 139)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203
    ';' 	shift, and go to state 384



state 380

    while_stmt  ->  WHILE '(' expr ')' stmt .   (rule 144)

    $default	reduce using rule 144 (while_stmt)



state 381

    if_stmt  ->  IF '(' expr ')' stmt .   (rule 137)
    if_stmt  ->  IF '(' expr ')' stmt . ELSE stmt   (rule 138)

    ELSE	shift, and go to state 385

    $default	reduce using rule 137 (if_stmt)



state 382

    c_c_init_list  ->  ID_NAME '(' const_expr ')' .   (rule 39)

    $default	reduce using rule 39 (c_c_init_list)



state 383

    c_c_init_list  ->  c_c_init_list ',' ID_NAME '(' . expr ')'   (rule 40)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    proc_call	go to state 132
    expr	go to state 386
    const_expr	go to state 134
    var_expr	go to state 135
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 384

    for_stmt  ->  FOR '(' var_decl ';' expr ';' . for_itr ')' block_stmt   (rule 139)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    assignment	go to state 387
    proc_call	go to state 132
    for_itr	go to state 388
    for_itr_elem	go to state 389
    expr	go to state 390
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 385

    if_stmt  ->  IF '(' expr ')' stmt ELSE . stmt   (rule 138)

    error	shift, and go to state 285
    EXTERN	shift, and go to state 3
    CIN 	shift, and go to state 286
    BREAK	shift, and go to state 287
    COUT	shift, and go to state 288
    FOR 	shift, and go to state 289
    DOUBLE	shift, and go to state 4
    RETURN	shift, and go to state 290
    WHILE	shift, and go to state 291
    CONTINUE	shift, and go to state 292
    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INT 	shift, and go to state 6
    BOOL_TYPE	shift, and go to state 7
    CHAR	shift, and go to state 8
    STATIC	shift, and go to state 9
    CONST	shift, and go to state 10
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    VOID	shift, and go to state 11
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131
    IF  	shift, and go to state 293
    '{' 	shift, and go to state 254

    storage_spec	go to state 295
    stmt	go to state 391
    simple_stmt	go to state 298
    var_decl	go to state 299
    assignment	go to state 300
    proc_call	go to state 132
    jump_stmt	go to state 301
    cin_stmt	go to state 302
    cout_stmt	go to state 303
    compound_stmt	go to state 304
    block_stmt	go to state 305
    if_stmt	go to state 306
    for_stmt	go to state 307
    while_stmt	go to state 308
    type	go to state 309
    simple_type	go to state 33
    complex_type	go to state 34
    pointer_type	go to state 35
    reference_type	go to state 36
    expr	go to state 310
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 151



state 386

    c_c_init_list  ->  c_c_init_list ',' ID_NAME '(' expr . ')'   (rule 40)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ')' 	shift, and go to state 392
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203



state 387

    for_itr_elem  ->  assignment .   (rule 143)

    $default	reduce using rule 143 (for_itr_elem)



state 388

    for_stmt  ->  FOR '(' var_decl ';' expr ';' for_itr . ')' block_stmt   (rule 139)
    for_itr  ->  for_itr . ',' for_itr_elem   (rule 141)

    ')' 	shift, and go to state 393
    ',' 	shift, and go to state 394



state 389

    for_itr  ->  for_itr_elem .   (rule 140)

    $default	reduce using rule 140 (for_itr)



state 390

    for_itr_elem  ->  expr .   (rule 142)
    unary_expr  ->  expr . ICR   (rule 186)
    unary_expr  ->  expr . DECR   (rule 188)
    binary_expr  ->  expr . '+' expr   (rule 191)
    binary_expr  ->  expr . '-' expr   (rule 192)
    binary_expr  ->  expr . '/' expr   (rule 193)
    binary_expr  ->  expr . '*' expr   (rule 194)
    binary_expr  ->  expr . '<' expr   (rule 195)
    binary_expr  ->  expr . '>' expr   (rule 196)
    binary_expr  ->  expr . LE expr   (rule 197)
    binary_expr  ->  expr . GE expr   (rule 198)
    binary_expr  ->  expr . EQ expr   (rule 199)
    binary_expr  ->  expr . NE expr   (rule 200)
    binary_expr  ->  expr . OROR expr   (rule 201)
    binary_expr  ->  expr . ANDAND expr   (rule 202)

    LE  	shift, and go to state 190
    GE  	shift, and go to state 191
    EQ  	shift, and go to state 192
    NE  	shift, and go to state 193
    '<' 	shift, and go to state 194
    '>' 	shift, and go to state 195
    '+' 	shift, and go to state 196
    '-' 	shift, and go to state 197
    ANDAND	shift, and go to state 198
    OROR	shift, and go to state 199
    '*' 	shift, and go to state 200
    '/' 	shift, and go to state 201
    ICR 	shift, and go to state 202
    DECR	shift, and go to state 203

    $default	reduce using rule 142 (for_itr_elem)



state 391

    if_stmt  ->  IF '(' expr ')' stmt ELSE stmt .   (rule 138)

    $default	reduce using rule 138 (if_stmt)



state 392

    c_c_init_list  ->  c_c_init_list ',' ID_NAME '(' expr ')' .   (rule 40)

    $default	reduce using rule 40 (c_c_init_list)



state 393

    for_stmt  ->  FOR '(' var_decl ';' expr ';' for_itr ')' . block_stmt   (rule 139)

    '{' 	shift, and go to state 254

    block_stmt	go to state 395



state 394

    for_itr  ->  for_itr ',' . for_itr_elem   (rule 141)

    ID_NAME	shift, and go to state 114
    CLASS_ID	shift, and go to state 5
    INTEGER_CONST	shift, and go to state 115
    DOUBLE_CONST	shift, and go to state 116
    STRING_CONST	shift, and go to state 117
    CHARACTER_CONST	shift, and go to state 118
    FALSE_CONST	shift, and go to state 119
    TRUE_CONST	shift, and go to state 120
    NEW 	shift, and go to state 121
    DELETE	shift, and go to state 122
    THIS	shift, and go to state 123
    '+' 	shift, and go to state 124
    '-' 	shift, and go to state 125
    '*' 	shift, and go to state 126
    '&' 	shift, and go to state 127
    '!' 	shift, and go to state 128
    '(' 	shift, and go to state 129
    ICR 	shift, and go to state 130
    DECR	shift, and go to state 131

    assignment	go to state 387
    proc_call	go to state 132
    for_itr_elem	go to state 396
    expr	go to state 390
    const_expr	go to state 134
    var_expr	go to state 311
    array_expr	go to state 136
    pointer_val_expr	go to state 137
    unary_expr	go to state 138
    binary_expr	go to state 139
    allocate_expr	go to state 140
    new_expr	go to state 141
    delete_expr	go to state 142
    cast_expr	go to state 143
    class_type	go to state 144



state 395

    for_stmt  ->  FOR '(' var_decl ';' expr ';' for_itr ')' block_stmt .   (rule 139)

    $default	reduce using rule 139 (for_stmt)



state 396

    for_itr  ->  for_itr ',' for_itr_elem .   (rule 141)

    $default	reduce using rule 141 (for_itr)



state 397

    $   	go to state 398



state 398

    $   	go to state 399



state 399

    $default	accept
